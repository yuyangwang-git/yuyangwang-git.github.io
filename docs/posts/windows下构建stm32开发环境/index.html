<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Windows下构建STM32开发环境 | Yuyang Wang's Blog</title><meta name=keywords content="C++,STM32"><meta name=description content="Keil，狗都不用"><meta name=author content><link rel=canonical href=https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PG166B7MZ2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PG166B7MZ2",{anonymize_ip:!1})}</script><meta property="og:title" content="Windows下构建STM32开发环境"><meta property="og:description" content="Keil，狗都不用"><meta property="og:type" content="article"><meta property="og:url" content="https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"><meta property="og:image" content="https://yuyangwang-git.github.io/img/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-09-05T20:37:29+08:00"><meta property="article:modified_time" content="2022-09-05T20:37:29+08:00"><meta property="og:site_name" content="Yuyang Wang's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yuyangwang-git.github.io/img/cover.jpg"><meta name=twitter:title content="Windows下构建STM32开发环境"><meta name=twitter:description content="Keil，狗都不用"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yuyangwang-git.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Windows下构建STM32开发环境","item":"https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Windows下构建STM32开发环境","name":"Windows下构建STM32开发环境","description":"Keil，狗都不用","keywords":["C++","STM32"],"articleBody":"目标 在 Windows 下脱离 Keil MDK 完成 STM32L4xxx 系列 MCU 的开发和调试工作。\n网上很多教程在一些配置上解释的都有错误，或者根本没解释为什么要这样做，简单记录一下配置流程。\n为什么不用 Keil？\nKeil 狗都不用。\n为什么不用 PlatformIO？\nPlatformIO 是以开发板而非芯片为中心的 IDE，这就导致它更适合于 Arduino 这类开源硬件的开发，和实际的嵌入式开发需求不符合。PlatformIO 的开发者似乎也意识到了这个问题，在库里提供了部分 generic 配置文件，但覆盖面太窄了，并没有 STM32L4 的 generic 配置文件，手写.ini文件又太蠢了一些。\n为什么不用 stm32-for-vscode 和 Cortex-Debug 插件？\n第一次使用还是手动写写配置文件比较好，能熟悉一下每个工具。安装完这两个插件后就直接自动完成了所有工作，不利于前期学习。\n大体流程 使用 STM32CubeMX 生成配置代码及 Makefile\n使用 VS Code 编写程序\n在 VS Code 中调用 make 完成交叉编译\n使用 OpenOCD 完成程序的烧录和调试\n图中横线上方加粗的内容是脱离 Keil 开发和调试 STM32 程序必需的工具，横线下方为推荐的工具和插件。\n准备工作 安装必需的工具：\nSTM32CubeMX VS Code 除了上面两个之外，还需要安装：\nmake Arm GNU Toolchain Git Bash Windows 并不提供 make 命令，而 Mingw-w64 包含了了mingw64-make.exe程序，因此可以通过安装 Mingw-w64 来安装 make：\n将安装目录bin文件夹下的mingw64-make.exe复制一份，并重命名为make.exe；\n将bin文件夹添加到环境变量；\n在命令行执行make -v，确认环境变量配置正确。\n现在已经 2022 年了，网络上有不少互相抄来抄去教程，要求读者安装 GNU Arm Embedded Toolchain，然后甩一个旧版的下载链接。\n但实际上 Arm GNU Toolchain 已经取代了 GNU Arm Embedded Toolchain，后者被 Arm 标记为 discontinued，没有特殊理由当然应优先选择最新的 Toolchain。\n— Arm GNU Toolchain Official Site1\n环境配置 打开 STM32CubeMX，这里我们已经有了一个名为 Test 的工程，切换到 Project Manager，将 Toolchain/IDE 修改为 Makefile：\n修改完成后生成代码，在输出目录（我这里是E:\\Test）中，可以看到目录下已经有了一个 Makefile 文件。\n在该目录打开命令行（ powershell 或 cmd 均可），运行 make 命令，会得到下面的结果：\nPS E:\\Test\u003e make mkdir build process_begin: CreateProcess(NULL, mkdir build, ...) failed. make (e=2): 系统找不到指定的文件。 make: *** [Makefile:179: build] Error 2 这里产生了一个报错，提示没有找到 build 目录，为什么会产生这个错误我们在后面会解释，这里先不管它，在E:\\Test目录下我们手动创建一个文件夹build，再次执行命令make：\n如果最终得到以下输出结果，则说明程序编译没有任何问题，Mingw-w64和gcc-arm-none-eabi均已被正确安装。\narm-none-eabi-size build/Test.elf text data bss dec hex filename 4384 32 1568 5984 1760 build/Test.elf arm-none-eabi-objcopy -O ihex build/Test.elf build/Test.hex arm-none-eabi-objcopy -O binary -S build/Test.elf build/Test.bin 如果尝试执行make clean，也会遇到类似的错误：\nPS E:\\Test\u003e make clean rm -fR build process_begin: CreateProcess(NULL, rm -fR build, ...) failed. make (e=2): 系统找不到指定的文件。 make: [Makefile:185: clean] Error 2 (ignored) 造成这一问题的原因和mkdir无法执行的原因相同，将在后面进行解释。\n在 VS Code 中开发和编译程序 在调通前面的步骤之后，我们实际上已经可以脱离 Keil 环境完成 STM32 程序的编译，接下来还需要修改 VSCode 的配置，才能直接在 VSCode 中编译代码，并享受到 VSCode 提供的代码补全等功能。\n首先我们在 VSCode 中打开项目文件夹E:\\Test，我们将要修改下面三个文件的配置：\ntasks.json settings.json c_cpp_properties.json 这三个文件夹将被放置在工程目录下 .vscode 文件夹中。\ntasks.json tasks.json文件告诉了 VSCode 如何按照上一节的步骤编译我们的 STM32 项目，为了修改该文件，按下快捷键ctrl+shift+p，输入configure task，点击“配置任务”，并选择“使用模板创建tasks.json文件”，模板则选择Others，然后将下面的内容填入到新创建的tasks.json文件中：\n// tasks.json { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"Build\", \"type\": \"shell\", \"command\": \"make\", \"args\": [ \"-j16\" ], \"problemMatcher\": [\"$gcc\"], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ] } 复制上面这段内容时记得根据电脑实际配置修改args中的-j16参数，将16替换为CPU实际的线程数，其它内容保持不变，保存。\n随后，点击顶部菜单栏“终端”，“运行生成任务”，可以看到底部终端中 VSCode 将自动执行make -j16命令（尽管依然会出现错误，“系统找不到指定的文件”）。\nsettings.json 前面提到了，手动执行 make 时，产生了如下的错误：\nmkdir build process_begin: CreateProcess(NULL, mkdir build, ...) failed. make (e=2): 系统找不到指定的文件。 make: *** [Makefile:179: build] Error 2 这四行的意思很简单，第一行尝试执行了mkdir build命令来创建文件夹build，但第二行告诉我们mkdir build命令执行失败，如果我们看一下 Makefile文件，可以看到，build文件夹是编译结果的输出文件夹，如果这个文件夹未能正确创建，自然也就无法进行后续的编译操作。\n####################################### # paths ####################################### # Build path BUILD_DIR = build # 第 178 行 $(BUILD_DIR): mkdir $@ 此时在工程目录手动创建build文件夹虽然能够绕过问题，但为什么mkdir build会执行失败呢？问题就隐含在错误输出的第二行：\nprocess_begin: CreateProcess(NULL, mkdir build, ...) failed. 这里告诉我们，程序尝试通过CreateProcess()函数来创建一个新的进程，然而在 Windows 下，mkdir并非一个可执行文件（或者说，Windows 下并没有mkdir.exe），而仅仅是cmd.exe的一个内置命令，自然也就无法直接通过CreateProcess()来调用。\n类似的，rm，mv等 Linux 下可以随意调用的命令，在 Windows 下都无法直接通过CreateProcess()调用，这也是为什么无法直接运行make clean:\n####################################### # clean up ####################################### clean: -rm -fR $(BUILD_DIR) 这一问题的解决办法也很简单，在安装 Git 的同时我们同时也安装了 Git Bash，而 Git Bash 提供了大量 Unix 命令（如rm、cp、mv），只要在 Git Bash 下执行 make 就不会遇到这类问题了。\n那么如何修改 VSCode 工作区的默认终端环境为 Git Bash 呢？只需要修改工作区的setting.json文件即可达到目的。按下ctrl+shift+p，输入open Workspace Settings (JSON)，然后向其中填入：\n// settings.json { \"terminal.integrated.defaultProfile.windows\": \"Git Bash\" } 重新启动 VSCode 工作区，点击顶部菜单栏“终端”，“运行生成任务”，可以看到 STM32 工程已被正确编译。\nc_cpp_properties.json 在正确填写task.json和settings.json后，虽然我们已经可以绕开命令行操作，直接在 VSCode 中编译整个项目，但在 VSCode 中打开任意源文件（如main.c），仍会看到大量的红色波浪线，代码补全等功能依然无法使用。这就需要修改c_cpp_properties.json，使 VSCode IntelliSense 在正常工作。\n// c_cpp_properties.json { \"configurations\": [ { \"name\": \"STM32L475xx\", \"includePath\": [ \"${workspaceFolder}/**\" ], \"defines\": [ \"USE_HAL_DRIVER\", \"STM32L475xx\" ], \"compilerPath\": \"C:/Program Files/mingw-w64/bin/gcc.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\", \"configurationProvider\": \"ms-vscode.makefile-tools\" } ], \"version\": 4 } 这里要重点注意的主要是defines和compilerPath两个选项（至于name随便填就好了），defines实际上就是在 Keil 中填写的全局宏定义标识符（Preprocessor Symbols -\u003e Define）：\n而compilerPath则是我们之前安装的 Mingw-w64 编译器的路径，按实际情况填写就行。\n一些文章在配置c_cpp_properties.json时，还修改了includePath：\n\"includePath\": [ \"${workspaceFolder}/**\", \"${workspaceFolder}/Core/Inc\", \"${workspaceFolder}/Drivers/STM32L4xx_HAL_Driver/Inc\", \"${workspaceFolder}/Drivers/STM32L4xx_HAL_Driver/Inc/Legacy\", \"${workspaceFolder}/Drivers/CMSIS/Device/ST/STM32L4xx/Include\", \"${workspaceFolder}/Drivers/CMSIS/Include\" ], 这些文章把 Keil 中填写的 Include Paths 填入到了c_cpp_properties.json里，这种写法纯属画蛇添足，因为${workspaceFolder}/**就已经告诉了 VSCode 要递归遍历项目文件夹下的所有文件及其子文件，在后面手动添加的这些内容没有任何意义，正确的做法是要么只写第一行，要么不写第一行。\n简单总结 tasks.json：用于配置 VSCode 调用外部工具完成编译工作； settings.json：在该文件中修改工作区内使用的 terminal，以消除 make 命令执行时遇到的各种问题； c_cpp_properties.json：用于配置 VSCode 的智能感知插件，使其能正确解析工作区内所有代码，实现代码补全等功能。 Arm GNU Toolchain Downloads. ↩︎\n","wordCount":"460","inLanguage":"en","image":"https://yuyangwang-git.github.io/img/cover.jpg","datePublished":"2022-09-05T20:37:29+08:00","dateModified":"2022-09-05T20:37:29+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},"publisher":{"@type":"Organization","name":"Yuyang Wang's Blog","logo":{"@type":"ImageObject","url":"https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuyangwang-git.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuyangwang-git.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yuyangwang-git.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://example.org title=Server><span>Server</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yuyangwang-git.github.io>Home</a>&nbsp;»&nbsp;<a href=https://yuyangwang-git.github.io/posts/>Posts</a></div><h1 class=post-title>Windows下构建STM32开发环境</h1><div class=post-meta><span title='2022-09-05 20:37:29 +0800 CST'>September 5, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;460 words</div></header><figure class=entry-cover><img loading=lazy srcset="https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover_hu2050a00be48b56a62d1d4e6680485627_312611_360x0_resize_q75_box.jpg 360w ,https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover_hu2050a00be48b56a62d1d4e6680485627_312611_480x0_resize_q75_box.jpg 480w ,https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover_hu2050a00be48b56a62d1d4e6680485627_312611_720x0_resize_q75_box.jpg 720w ,https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover_hu2050a00be48b56a62d1d4e6680485627_312611_1080x0_resize_q75_box.jpg 1080w ,https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover_hu2050a00be48b56a62d1d4e6680485627_312611_1500x0_resize_q75_box.jpg 1500w ,https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover.jpg 1920w" sizes="(min-width: 768px) 720px, 100vw" src=https://yuyangwang-git.github.io/posts/windows%E4%B8%8B%E6%9E%84%E5%BB%BAstm32%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/img/cover.jpg alt width=1920 height=1359></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#目标>目标</a></li><li><a href=#大体流程>大体流程</a></li><li><a href=#准备工作>准备工作</a></li><li><a href=#环境配置>环境配置</a></li><li><a href=#在-vs-code-中开发和编译程序>在 VS Code 中开发和编译程序</a><ul><li><a href=#tasksjson>tasks.json</a></li><li><a href=#settingsjson>settings.json</a></li><li><a href=#c_cpp_propertiesjson>c_cpp_properties.json</a></li><li><a href=#简单总结>简单总结</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=目标>目标<a hidden class=anchor aria-hidden=true href=#目标>#</a></h2><p>在 Windows 下脱离 Keil MDK 完成 STM32L4xxx 系列 MCU 的开发和调试工作。</p><p>网上很多教程在一些配置上解释的都有错误，或者根本没解释为什么要这样做，简单记录一下配置流程。</p><blockquote><p><strong>为什么不用 Keil？</strong></p><p>Keil 狗都不用。</p><p><strong>为什么不用 PlatformIO？</strong></p><p>PlatformIO 是以开发板而非芯片为中心的 IDE，这就导致它更适合于 Arduino 这类开源硬件的开发，和实际的嵌入式开发需求不符合。PlatformIO 的开发者似乎也意识到了这个问题，在库里提供了部分 generic 配置文件，但覆盖面太窄了，并没有 STM32L4 的 generic 配置文件，手写<code>.ini</code>文件又太蠢了一些。</p><p><strong>为什么不用 stm32-for-vscode 和 Cortex-Debug 插件？</strong></p><p>第一次使用还是手动写写配置文件比较好，能熟悉一下每个工具。安装完这两个插件后就直接自动完成了所有工作，不利于前期学习。</p></blockquote><h2 id=大体流程>大体流程<a hidden class=anchor aria-hidden=true href=#大体流程>#</a></h2><ol><li><p>使用 STM32CubeMX 生成配置代码及 Makefile</p></li><li><p>使用 VS Code 编写程序</p></li><li><p>在 VS Code 中调用 make 完成交叉编译</p></li><li><p>使用 OpenOCD 完成程序的烧录和调试</p></li></ol><p><img loading=lazy src=img/flowchart.svg#center alt=flowchart></p><blockquote><p>图中横线上方加粗的内容是脱离 Keil 开发和调试 STM32 程序必需的工具，横线下方为推荐的工具和插件。</p></blockquote><h2 id=准备工作>准备工作<a hidden class=anchor aria-hidden=true href=#准备工作>#</a></h2><p>安装必需的工具：</p><ul><li>STM32CubeMX</li><li>VS Code</li></ul><p>除了上面两个之外，还需要安装：</p><ul><li>make</li><li>Arm GNU Toolchain</li><li>Git Bash</li></ul><blockquote><p>Windows 并不提供 make 命令，而 Mingw-w64 包含了了<code>mingw64-make.exe</code>程序，因此可以通过安装 Mingw-w64 来安装 make：</p><ol><li><p>将安装目录<code>bin</code>文件夹下的<code>mingw64-make.exe</code>复制一份，并重命名为<code>make.exe</code>；</p></li><li><p>将<code>bin</code>文件夹添加到环境变量；</p></li><li><p>在命令行执行<code>make -v</code>，确认环境变量配置正确。</p></li></ol></blockquote><blockquote><p>现在已经 2022 年了，网络上有不少互相抄来抄去教程，要求读者安装 GNU Arm Embedded Toolchain，然后甩一个旧版的下载链接。</p><p>但实际上 Arm GNU Toolchain 已经取代了 GNU Arm Embedded Toolchain，后者被 Arm 标记为 discontinued，没有特殊理由当然应优先选择最新的 Toolchain。</p><p>— Arm GNU Toolchain Official Site<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><h2 id=环境配置>环境配置<a hidden class=anchor aria-hidden=true href=#环境配置>#</a></h2><p>打开 STM32CubeMX，这里我们已经有了一个名为 Test 的工程，切换到 Project Manager，将 Toolchain/IDE 修改为 Makefile：</p><p><img loading=lazy src=img/STM32CubeMX.png#center alt=STM32CubeMX></p><p>修改完成后生成代码，在输出目录（我这里是<code>E:\Test</code>）中，可以看到目录下已经有了一个 Makefile 文件。</p><p>在<strong>该目录</strong>打开命令行（ powershell 或 cmd 均可），运行 <code>make</code> 命令，会得到下面的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PS E:<span style=color:#ae81ff>\T</span>est&gt; make
</span></span><span style=display:flex><span>mkdir build
</span></span><span style=display:flex><span>process_begin: CreateProcess<span style=color:#f92672>(</span>NULL, mkdir build, ...<span style=color:#f92672>)</span> failed.
</span></span><span style=display:flex><span>make <span style=color:#f92672>(</span>e<span style=color:#f92672>=</span>2<span style=color:#f92672>)</span>: 系统找不到指定的文件。
</span></span><span style=display:flex><span>make: *** <span style=color:#f92672>[</span>Makefile:179: build<span style=color:#f92672>]</span> Error <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>这里产生了一个报错，提示没有找到 build 目录，为什么会产生这个错误我们在后面会解释，这里先不管它，在<code>E:\Test</code>目录下我们手动创建一个文件夹<code>build</code>，再次执行命令<code>make</code>：</p><p><img loading=lazy src=img/make.png#center alt=make></p><p>如果最终得到以下输出结果，则说明程序编译没有任何问题，<code>Mingw-w64</code>和<code>gcc-arm-none-eabi</code>均已被正确安装。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>arm-none-eabi-size build/Test.elf
</span></span><span style=display:flex><span>   text    data     bss     dec     hex filename
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>4384</span>      <span style=color:#ae81ff>32</span>    <span style=color:#ae81ff>1568</span>    <span style=color:#ae81ff>5984</span>    <span style=color:#ae81ff>1760</span> build/Test.elf
</span></span><span style=display:flex><span>arm-none-eabi-objcopy -O ihex build/Test.elf build/Test.hex
</span></span><span style=display:flex><span>arm-none-eabi-objcopy -O binary -S build/Test.elf build/Test.bin
</span></span></code></pre></div><blockquote><p>如果尝试执行<code>make clean</code>，也会遇到类似的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>PS E:<span style=color:#ae81ff>\T</span>est&gt; make clean
</span></span><span style=display:flex><span>rm -fR build
</span></span><span style=display:flex><span>process_begin: CreateProcess<span style=color:#f92672>(</span>NULL, rm -fR build, ...<span style=color:#f92672>)</span> failed.
</span></span><span style=display:flex><span>make <span style=color:#f92672>(</span>e<span style=color:#f92672>=</span>2<span style=color:#f92672>)</span>: 系统找不到指定的文件。
</span></span><span style=display:flex><span>make: <span style=color:#f92672>[</span>Makefile:185: clean<span style=color:#f92672>]</span> Error <span style=color:#ae81ff>2</span> <span style=color:#f92672>(</span>ignored<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>造成这一问题的原因和<code>mkdir</code>无法执行的原因相同，将在后面进行解释。</p></blockquote><h2 id=在-vs-code-中开发和编译程序>在 VS Code 中开发和编译程序<a hidden class=anchor aria-hidden=true href=#在-vs-code-中开发和编译程序>#</a></h2><p>在调通前面的步骤之后，我们实际上已经可以脱离 Keil 环境完成 STM32 程序的编译，接下来还需要修改 VSCode 的配置，才能直接在 VSCode 中编译代码，并享受到 VSCode 提供的代码补全等功能。</p><p>首先我们在 VSCode 中打开项目文件夹<code>E:\Test</code>，我们将要修改下面三个文件的配置：</p><ul><li><code>tasks.json</code></li><li><code>settings.json</code></li><li><code>c_cpp_properties.json</code></li></ul><p>这三个文件夹将被放置在工程目录下 <code>.vscode</code> 文件夹中。</p><h3 id=tasksjson>tasks.json<a hidden class=anchor aria-hidden=true href=#tasksjson>#</a></h3><p><code>tasks.json</code>文件告诉了 VSCode 如何按照上一节的步骤编译我们的 STM32 项目，为了修改该文件，按下快捷键<code>ctrl+shift+p</code>，输入<code>configure task</code>，点击“配置任务”，并选择“使用模板创建<code>tasks.json</code>文件”，模板则选择<code>Others</code>，然后将下面的内容填入到新创建的<code>tasks.json</code>文件中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#75715e>// tasks.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#e6db74>&#34;2.0.0&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;tasks&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;label&#34;</span>: <span style=color:#e6db74>&#34;Build&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;shell&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;command&#34;</span>: <span style=color:#e6db74>&#34;make&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;args&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;-j16&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;problemMatcher&#34;</span>: [<span style=color:#e6db74>&#34;$gcc&#34;</span>],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;group&#34;</span>: {
</span></span><span style=display:flex><span>              <span style=color:#f92672>&#34;kind&#34;</span>: <span style=color:#e6db74>&#34;build&#34;</span>,
</span></span><span style=display:flex><span>              <span style=color:#f92672>&#34;isDefault&#34;</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>复制上面这段内容时记得根据电脑实际配置修改<code>args</code>中的<code>-j16</code>参数，将<code>16</code>替换为CPU实际的线程数，其它内容保持不变，保存。</p><p>随后，点击顶部菜单栏“终端”，“运行生成任务”，可以看到底部终端中 VSCode 将自动执行<code>make -j16</code>命令（尽管依然会出现错误，“系统找不到指定的文件”）。</p><h3 id=settingsjson>settings.json<a hidden class=anchor aria-hidden=true href=#settingsjson>#</a></h3><p>前面提到了，手动执行 <code>make</code> 时，产生了如下的错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir build
</span></span><span style=display:flex><span>process_begin: CreateProcess<span style=color:#f92672>(</span>NULL, mkdir build, ...<span style=color:#f92672>)</span> failed.
</span></span><span style=display:flex><span>make <span style=color:#f92672>(</span>e<span style=color:#f92672>=</span>2<span style=color:#f92672>)</span>: 系统找不到指定的文件。
</span></span><span style=display:flex><span>make: *** <span style=color:#f92672>[</span>Makefile:179: build<span style=color:#f92672>]</span> Error <span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>这四行的意思很简单，第一行尝试执行了<code>mkdir build</code>命令来创建文件夹<code>build</code>，但第二行告诉我们<code>mkdir build</code>命令执行失败，如果我们看一下 <code>Makefile</code>文件，可以看到，<code>build</code>文件夹是编译结果的输出文件夹，如果这个文件夹未能正确创建，自然也就无法进行后续的编译操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#75715e>#######################################
</span></span></span><span style=display:flex><span><span style=color:#75715e># paths
</span></span></span><span style=display:flex><span><span style=color:#75715e>#######################################
</span></span></span><span style=display:flex><span><span style=color:#75715e># Build path
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>BUILD_DIR <span style=color:#f92672>=</span> build
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 第 178 行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>$(BUILD_DIR)</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    mkdir $@
</span></span></code></pre></div><p>此时在工程目录手动创建<code>build</code>文件夹虽然能够绕过问题，但为什么<code>mkdir build</code>会执行失败呢？问题就隐含在错误输出的第二行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>process_begin: CreateProcess<span style=color:#f92672>(</span>NULL, mkdir build, ...<span style=color:#f92672>)</span> failed.
</span></span></code></pre></div><p>这里告诉我们，程序尝试通过<code>CreateProcess()</code>函数来创建一个新的进程，然而在 Windows 下，<code>mkdir</code>并非一个可执行文件（或者说，Windows 下并没有<code>mkdir.exe</code>），而仅仅是<code>cmd.exe</code>的一个内置命令，自然也就无法直接通过<code>CreateProcess()</code>来调用。</p><blockquote><p>类似的，<code>rm</code>，<code>mv</code>等 Linux 下可以随意调用的命令，在 Windows 下都无法直接通过<code>CreateProcess()</code>调用，这也是为什么无法直接运行<code>make clean</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#75715e>#######################################
</span></span></span><span style=display:flex><span><span style=color:#75715e># clean up
</span></span></span><span style=display:flex><span><span style=color:#75715e>#######################################
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>clean</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    -rm -fR <span style=color:#66d9ef>$(</span>BUILD_DIR<span style=color:#66d9ef>)</span>
</span></span></code></pre></div></blockquote><p>这一问题的解决办法也很简单，在安装 Git 的同时我们同时也安装了 Git Bash，而 Git Bash 提供了大量 Unix 命令（如<code>rm</code>、<code>cp</code>、<code>mv</code>），只要在 Git Bash 下执行 <code>make</code> 就不会遇到这类问题了。</p><p>那么如何修改 VSCode 工作区的默认终端环境为 Git Bash 呢？只需要修改工作区的<code>setting.json</code>文件即可达到目的。按下<code>ctrl+shift+p</code>，输入<code>open Workspace Settings (JSON)</code>，然后向其中填入：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JSON data-lang=JSON><span style=display:flex><span><span style=color:#75715e>// settings.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;terminal.integrated.defaultProfile.windows&#34;</span>: <span style=color:#e6db74>&#34;Git Bash&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>重新启动 VSCode 工作区，点击顶部菜单栏“终端”，“运行生成任务”，可以看到 STM32 工程已被正确编译。</p><h3 id=c_cpp_propertiesjson>c_cpp_properties.json<a hidden class=anchor aria-hidden=true href=#c_cpp_propertiesjson>#</a></h3><p>在正确填写<code>task.json</code>和<code>settings.json</code>后，虽然我们已经可以绕开命令行操作，直接在 VSCode 中编译整个项目，但在 VSCode 中打开任意源文件（如<code>main.c</code>），仍会看到大量的红色波浪线，代码补全等功能依然无法使用。这就需要修改<code>c_cpp_properties.json</code>，使 VSCode IntelliSense 在正常工作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Json data-lang=Json><span style=display:flex><span><span style=color:#75715e>// c_cpp_properties.json
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;configurations&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;name&#34;</span>: <span style=color:#e6db74>&#34;STM32L475xx&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;includePath&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;${workspaceFolder}/**&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;defines&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;USE_HAL_DRIVER&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;STM32L475xx&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;compilerPath&#34;</span>: <span style=color:#e6db74>&#34;C:/Program Files/mingw-w64/bin/gcc.exe&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;cStandard&#34;</span>: <span style=color:#e6db74>&#34;c17&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;cppStandard&#34;</span>: <span style=color:#e6db74>&#34;c++17&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;intelliSenseMode&#34;</span>: <span style=color:#e6db74>&#34;gcc-x64&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;configurationProvider&#34;</span>: <span style=color:#e6db74>&#34;ms-vscode.makefile-tools&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;version&#34;</span>: <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里要重点注意的主要是<code>defines</code>和<code>compilerPath</code>两个选项（至于<code>name</code>随便填就好了），<code>defines</code>实际上就是在 Keil 中填写的全局宏定义标识符（Preprocessor Symbols -> Define）：</p><p><img loading=lazy src=img/Keil.png#center alt="Keil Defines"></p><p>而<code>compilerPath</code>则是我们之前安装的 Mingw-w64 编译器的路径，按实际情况填写就行。</p><blockquote><p>一些文章在配置<code>c_cpp_properties.json</code>时，还修改了<code>includePath</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Json data-lang=Json><span style=display:flex><span><span style=color:#e6db74>&#34;includePath&#34;</span><span style=color:#960050;background-color:#1e0010>:</span> [
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;${workspaceFolder}/**&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;${workspaceFolder}/Core/Inc&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;${workspaceFolder}/Drivers/STM32L4xx_HAL_Driver/Inc&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;${workspaceFolder}/Drivers/STM32L4xx_HAL_Driver/Inc/Legacy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;${workspaceFolder}/Drivers/CMSIS/Device/ST/STM32L4xx/Include&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;${workspaceFolder}/Drivers/CMSIS/Include&#34;</span>
</span></span><span style=display:flex><span>]<span style=color:#960050;background-color:#1e0010>,</span>
</span></span></code></pre></div><p>这些文章把 Keil 中填写的 Include Paths 填入到了<code>c_cpp_properties.json</code>里，这种写法纯属画蛇添足，因为<code>${workspaceFolder}/**</code>就已经告诉了 VSCode 要递归遍历项目文件夹下的所有文件及其子文件，在后面手动添加的这些内容没有任何意义，正确的做法是要么只写第一行，要么不写第一行。</p></blockquote><h3 id=简单总结>简单总结<a hidden class=anchor aria-hidden=true href=#简单总结>#</a></h3><ul><li><code>tasks.json</code>：用于配置 VSCode 调用外部工具完成编译工作；</li><li><code>settings.json</code>：在该文件中修改工作区内使用的 terminal，以消除 <code>make</code> 命令执行时遇到的各种问题；</li><li><code>c_cpp_properties.json</code>：用于配置 VSCode 的智能感知插件，使其能正确解析工作区内所有代码，实现代码补全等功能。</li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads>Arm GNU Toolchain Downloads</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuyangwang-git.github.io/tags/c++/>C++</a></li><li><a href=https://yuyangwang-git.github.io/tags/stm32/>STM32</a></li></ul><nav class=paginav><a class=next href=https://yuyangwang-git.github.io/posts/%E4%BD%BF%E7%94%A8matlab-coder%E7%94%9F%E6%88%90cpp%E6%BA%90%E7%A0%81/><span class=title>Next »</span><br><span>使用 MATLAB Coder 生成 Cpp 源码</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://yuyangwang-git.github.io>Yuyang Wang's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>