<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Javascript异步编程 | Yuyang Wang's Blog</title><meta name=keywords content="Javascript,async"><meta name=description content="简单梳理一下Javascript异步编程相关知识"><meta name=author content><link rel=canonical href=https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-PG166B7MZ2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PG166B7MZ2",{anonymize_ip:!1})}</script><meta property="og:title" content="Javascript异步编程"><meta property="og:description" content="简单梳理一下Javascript异步编程相关知识"><meta property="og:type" content="article"><meta property="og:url" content="https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><meta property="og:image" content="https://yuyangwang-git.github.io/img/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-01-26T21:58:57+08:00"><meta property="article:modified_time" content="2022-01-26T21:58:57+08:00"><meta property="og:site_name" content="Yuyang Wang's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yuyangwang-git.github.io/img/cover.jpg"><meta name=twitter:title content="Javascript异步编程"><meta name=twitter:description content="简单梳理一下Javascript异步编程相关知识"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yuyangwang-git.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Javascript异步编程","item":"https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Javascript异步编程","name":"Javascript异步编程","description":"简单梳理一下Javascript异步编程相关知识","keywords":["Javascript","async"],"articleBody":"第一次接触Javascript这样基于事件模型的单线程语言，简单梳理一下异步编程这块的内容。\n回调函数 回调函数（Callback）的概念其实很简单，在很多语言里都很常见：\nfunction add(x, y) { return x + y } function doSomething(x, y, func) { console.log( func(x, y) ) } doSomething(1, 2, add) // 3 这里add()就是传给doSomething()的一个回调函数。说白了，“回调”就是把一个函数作为参数传递给另一个函数。\n在C等更接近底层的语言中，可以使用函数指针来达到“传递代码块”的目的；而在Python或Javascript中，直接使用函数名就可以直接实现这一过程。\n这里很显然，在调用doSomething()之后立即执行了传入的函数func，所以这就是一个最简单的同步回调（synchronous callback），同步回调还有一个名字叫“阻塞回调（blocking callback）”，因为如果回调函数过于复杂，它会直接阻塞CPU直到执行完成。\n有同步回调，自然有异步回调，异步回调（asynchronous callback）不会立即执行传入的代码，因此不会立即阻塞CPU的运行：\nfunction add(x, y) { return x + y } function doSomething(x, y, func) { setTimeout( () =\u003e { console.log( func(x, y) ) }, 1000) } doSomething(1, 2, add) console.log(\"***\") // 输出如下: // *** // 随后等待约 1000ms, 输出: // 3 所以异步回调还有一个更形象的名字——延迟回调（deferred callback）\n异步回调函数 异步是异步，回调是回调，异步回调是基于回调实现的一种异步编程手段。\n— 周树人\n在调用一个普通的函数时，我们可以直接使用函数的返回值来进行后续操作：\nlet result = Math.pow(4, 0.5) console.log(result) 但是，如果遇到一个耗时较长的操作（读写大文件、网络请求等），这种方式将长时间阻塞程序，无疑是对CPU资源的一种浪费：\n// ...... let photo = downloadFile(\"www.hello.com/test.png\") // 将在这里被阻塞 photo = resize(photo) show(photo) // ...... 其它编程语言（C++, Java, Python…）大多可以通过多线程/多进程来解决这一问题，但由于Javascript不支持多线程/进程操作，因此只能通过异步的方式来间接的达到并发的目的。\n在Javascript中如何实现异步编程呢？一种最常用的解决方法是使用异步回调函数：\n// ...... function handlePhoto(photo) { photo = resize(photo) show(photo) } downloadFile(\"www.hello.com/test.png\", (photo) =\u003e handlePhoto(photo)) // ...... 在使用常规函数的过程中，是将变量（如photo）传入到这些函数中（如resize()），再由函数内部的代码对输入进行必要的处理；\n而使用异步回调函数的思路与使用普通函数的思路并不完全相同，使用回调函数时是将一段代码（如handlePhoto()）作为参数来传入到即将产生变量（如photo）的函数内（如downloadFile()）。这样，在执行到downloadFile()语句时，浏览器会一边下载图片，一边继续执行downloadFile()后面的代码；待图片下载完成后，再回过头来调用传入的回调函数handlePhoto()（为什么会按这样的异步顺序执行，和downloadFile()这类函数的实现有关，这里暂不讨论）。\n这就产生了一个新的问题，继续上面的例子，如果想要在回调函数外对photo进行其它操作，应该怎样做呢？答案是不可行的，因为根本无法获取回调函数的返回值，这是由回调函数本身的特性决定的，与异步无关。\n// ...... function handlePhoto(photo) { photo = resize(photo) show(photo) return photo // 没有任何意义, 无法在函数外拿到返回值 } downloadFile(\"www.hello.com/test.png\", (photo) =\u003e handlePhoto(photo)) save(photo) // ...... 换句话说，唯一的解决方法，就是把后续代码中所有涉及变量photo的操作全部移动到handlePhoto()内。\n另外，一个合格的程序，还应当具有异常处理等功能。很显然，这样最后会得到一个非常臃肿的handlePhoto()函数：\n// ...... function handlePhoto(photo) { photo = resize(photo) show(photo) save(photo) // 其它各种操作 // ...... } downloadFile(\"www.hello.com/test.png\", (photo) =\u003e handlePhoto(photo)) // ...... 随着程序越来越复杂，还有可能陷入到深层次嵌套的回调地狱（callback hell）中。按照惯例，应当避免两层以上的函数嵌套。\nPromise 为了解决前面提到的回调地狱等问题，ES6中引入了Promise类型，利用Promise语法，可以轻松的将一个深度嵌套的回调函数改写成一种顺序的、更加易于理解的形式（即没有复杂的嵌套）：\nlet p = new Promise((resolve, reject) =\u003e { // new 一个 Promise 类, 并向 Promise 类的构造器传递一个函数 downloadFile(\"www.hello.com/test.png\", (photo) =\u003e { if(photo) { // 处理下载失败的情况 reject('Download Failed') } else { resolve(photo) // 处理下载成功的情况 } }) }) p.catch(errorMessage =\u003e { // 如果下载失败, 执行该语句 console.log(errorMessage) }) p.then(photo =\u003e { // 如果下载成功, 继续执行该语句 photo = resize(photo) return photo }).then(photo =\u003e { // 如果上一部分执行成功, 继续执行该语句 show(photo) save(photo) return photo }) p.then(phoyo =\u003e { // 如果上一部分执行成功, 继续执行该语句 // 其它各种操作 // ...... }) Promise的用法也很简单，首先要使用new运算符实例化一个Promise对象，Promise类的构造器可以被用来包装任意一个返回值不是Promise类型的函数，如上面的第一行代码：\nlet p = new Promise((resolve, reject) =\u003e { // new 一个 Promise 对象, 并向 Promise 类的构造器传递了一个函数 downloadFile(\"www.hello.com/test.png\", (photo) =\u003e { if(photo) { // 处理下载失败的情况 reject('Download Failed') } else { resolve(photo) // 处理下载成功的情况 } }) }) 上面向Promise构造器传递了一个具有两个参数的匿名函数，实际上也就等价于下面这段代码：\nlet p = new Promise(getPhoto) function getPhoto(resolve, reject) { downloadFile(\"www.hello.com/test.png\", (photo) =\u003e { if(photo) { reject('Download Failed') } else { resolve(photo) } }) } 简单的说，我们向Promise构造器传入了一个回调函数，该回调函数将被传入两个参数resolve和reject，下面来解释一下这两个参数的含义：\n我们在做任何一件事情的过程中，都一定存在且只存在三种情况：\n这件事情尚未完成（还没开始 or 正在进行） 已经执行完成 执行失败 吃饭了吗？\n还没吃/正在吃、吃完了、吃了，但吃到了奇怪的东西。\n前面我们已经把要做的事情（下载文件）包装到一个Promise对象里，那现在这个事情（Promise对象）执行到哪一步了呢？在Promise中，我们使用：\npending（待定） resolve（解决，或fulfilled） reject（拒绝） 来描述这三种状态，任意Promise对象的状态都一定是这三种状态之一。\n这样，当使用new运算符创建一个新的Promise对象时，该对象的状态就是待定的pending状态；而如果执行了resolve()函数，Promise对象将转变为fulfilled状态，表明程序执行成功；同样的，如果调用reject()，则将转变为reject状态，表明程序执行失败。\n那么改变Promise的状态又有什么效果呢？在前面的程序中，我们向.then()和.catch()方法各自传入了一个回调函数。如果Promise的状态变为fulfilled，就会执行传给.then()的函数；如果Promise的状态变为reject，就会执行传给.catch()的函数，这样就优雅的实现了异步函数的顺序执行，从而避免了回调函数的深层次嵌套。\n接下来注意到，前面的程序在调用resolve()和reject()时，还向它们传递了参数：\n// ...... if(photo) { reject('Download Failed') } else { resolve(photo) } // ...... 其实作用也很明显，传给reject()和resolve()的参数将作为回调函数的参数再次传递给紧跟其后的.catch()或.then()方法，所以才会有：\np.catch(errorMessage =\u003e { // 如果下载失败, 执行该语句 console.log(errorMessage) }) p.then(photo =\u003e { // 如果下载成功, 继续执行该语句 photo = resize(photo) return photo // 将 photo 传递给下一个 .then() 方法 }) 另外，.then()和.catch()方法还有一个重要的性质，即它们都会返回一个Promise对象，这样就可以随意的实现Promise的链式调用：\np.then(photo =\u003e { // 如果下载成功, 继续执行该语句 photo = resize(photo) return photo // 这里的 return 只是将 photo 作为回调函数的参数 (划重点) // 传递给下一个 .then() 方法, 而 .then() 返回的仍然是 Promise 对象, 不是 photo }).then(photo =\u003e { // 如果上一部分执行成功, 继续执行该语句 show(photo) save(photo) return photo }) 在使用Promise编写程序时，.then()和.catch()方法的调用顺序其实也有讲究，但这里就不对该问题做进一步讨论了。\n最后还有一个问题，为什么Promise还允许用户传入一个用于异常处理的回调函数reject()，而不是让用户直接通过try...catch()来捕获异常？这个其实是因为在Javascript中，try...catch()语句块无法捕获异步回调中的异常：\ntry { setTimeout(function() { throw new Error('You can not catch this error.') }, 0) } catch (e) { console.error(e) } 在setTimeout()内抛出的异常是无法被try...catch()直接捕获的。\nAsync/Await Promise虽然已经解决了回调地狱的问题，但仍不够优雅————大量的.then()和.catch()语句块依然看着很傻。\n于是，Javascript的设计者又设计出新的语法糖————async和await关键字。\n待更。\n","wordCount":"435","inLanguage":"en","image":"https://yuyangwang-git.github.io/img/cover.jpg","datePublished":"2022-01-26T21:58:57+08:00","dateModified":"2022-01-26T21:58:57+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},"publisher":{"@type":"Organization","name":"Yuyang Wang's Blog","logo":{"@type":"ImageObject","url":"https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuyangwang-git.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuyangwang-git.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yuyangwang-git.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://example.org title=Server><span>Server</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yuyangwang-git.github.io>Home</a>&nbsp;»&nbsp;<a href=https://yuyangwang-git.github.io/posts/>Posts</a></div><h1 class=post-title>Javascript异步编程</h1><div class=post-description>简单梳理一下Javascript异步编程相关知识</div><div class=post-meta><span title='2022-01-26 21:58:57 +0800 CST'>January 26, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;435 words</div></header><figure class=entry-cover><img loading=lazy srcset="https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover_huc048d3c5a098d1ec65119e05e15bbfe7_128148_360x0_resize_q75_box.jpg 360w ,https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover_huc048d3c5a098d1ec65119e05e15bbfe7_128148_480x0_resize_q75_box.jpg 480w ,https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover_huc048d3c5a098d1ec65119e05e15bbfe7_128148_720x0_resize_q75_box.jpg 720w ,https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover_huc048d3c5a098d1ec65119e05e15bbfe7_128148_1080x0_resize_q75_box.jpg 1080w ,https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover_huc048d3c5a098d1ec65119e05e15bbfe7_128148_1500x0_resize_q75_box.jpg 1500w ,https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover.jpg 3072w" sizes="(min-width: 768px) 720px, 100vw" src=https://yuyangwang-git.github.io/posts/javascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/img/cover.jpg alt width=3072 height=2048></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#回调函数>回调函数</a></li><li><a href=#异步回调函数>异步回调函数</a></li><li><a href=#promise>Promise</a></li><li><a href=#asyncawait>Async/Await</a></li></ul></nav></div></details></div><div class=post-content><p>第一次接触Javascript这样基于事件模型的单线程语言，简单梳理一下异步编程这块的内容。</p><h2 id=回调函数>回调函数<a hidden class=anchor aria-hidden=true href=#回调函数>#</a></h2><p>回调函数（Callback）的概念其实很简单，在很多语言里都很常见：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>func</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>func</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>doSomething</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>add</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 3
</span></span></span></code></pre></div><p>这里<code>add()</code>就是传给<code>doSomething()</code>的一个回调函数。说白了，“回调”就是把一个函数作为参数传递给另一个函数。</p><p>在C等更接近底层的语言中，可以使用函数指针来达到“传递代码块”的目的；而在Python或Javascript中，直接使用函数名就可以直接实现这一过程。</p><p>这里很显然，在调用<code>doSomething()</code>之后立即执行了传入的函数<code>func</code>，所以这就是一个最简单的同步回调（synchronous callback），同步回调还有一个名字叫“阻塞回调（blocking callback）”，因为如果回调函数过于复杂，它会直接阻塞CPU直到执行完成。</p><p>有同步回调，自然有异步回调，异步回调（asynchronous callback）不会立即执行传入的代码，因此不会立即阻塞CPU的运行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>doSomething</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>func</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setTimeout</span>( () =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>( <span style=color:#a6e22e>func</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span>) )
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>doSomething</span>(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#a6e22e>add</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;***&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 输出如下:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ***
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 随后等待约 1000ms, 输出:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 3
</span></span></span></code></pre></div><p>所以异步回调还有一个更形象的名字——延迟回调（deferred callback）</p><h2 id=异步回调函数>异步回调函数<a hidden class=anchor aria-hidden=true href=#异步回调函数>#</a></h2><blockquote><p>异步是异步，回调是回调，异步回调是基于回调实现的一种异步编程手段。</p><p>— 周树人</p></blockquote><p>在调用一个普通的函数时，我们可以直接使用函数的返回值来进行后续操作：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>pow</span>(<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>result</span>)
</span></span></code></pre></div><p>但是，如果遇到一个耗时较长的操作（读写大文件、网络请求等），这种方式将长时间阻塞程序，无疑是对CPU资源的一种浪费：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>)         <span style=color:#75715e>// 将在这里被阻塞
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>show</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span></code></pre></div><p>其它编程语言（C++, Java, Python&mldr;）大多可以通过多线程/多进程来解决这一问题，但由于Javascript不支持多线程/进程操作，因此只能通过异步的方式来间接的达到并发的目的。</p><p>在Javascript中如何实现异步编程呢？一种最常用的解决方法是使用异步回调函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handlePhoto</span>(<span style=color:#a6e22e>photo</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>show</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>, (<span style=color:#a6e22e>photo</span>) =&gt; <span style=color:#a6e22e>handlePhoto</span>(<span style=color:#a6e22e>photo</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span></code></pre></div><p>在使用常规函数的过程中，是将变量（如<code>photo</code>）传入到这些函数中（如<code>resize()</code>），再由函数内部的代码对输入进行必要的处理；</p><p>而使用异步回调函数的思路与使用普通函数的思路并不完全相同，使用回调函数时是将一段代码（如<code>handlePhoto()</code>）作为参数来传入到即将产生变量（如<code>photo</code>）的函数内（如<code>downloadFile()</code>）。这样，在执行到<code>downloadFile()</code>语句时，浏览器会一边下载图片，一边继续执行<code>downloadFile()</code>后面的代码；待图片下载完成后，再回过头来调用传入的回调函数<code>handlePhoto()</code>（为什么会按这样的异步顺序执行，和<code>downloadFile()</code>这类函数的实现有关，这里暂不讨论）。</p><p>这就产生了一个新的问题，继续上面的例子，如果想要在回调函数外对<code>photo</code>进行其它操作，应该怎样做呢？答案是不可行的，因为<strong>根本无法获取回调函数的返回值</strong>，这是由回调函数本身的特性决定的，<strong>与异步无关</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handlePhoto</span>(<span style=color:#a6e22e>photo</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>show</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>photo</span>                  <span style=color:#75715e>// 没有任何意义, 无法在函数外拿到返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>, (<span style=color:#a6e22e>photo</span>) =&gt; <span style=color:#a6e22e>handlePhoto</span>(<span style=color:#a6e22e>photo</span>))
</span></span><span style=display:flex><span><span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span></code></pre></div><p>换句话说，唯一的解决方法，就是把后续代码中所有涉及变量<code>photo</code>的操作全部移动到<code>handlePhoto()</code>内。</p><p>另外，一个合格的程序，还应当具有异常处理等功能。很显然，这样最后会得到一个非常臃肿的<code>handlePhoto()</code>函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>handlePhoto</span>(<span style=color:#a6e22e>photo</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>show</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 其它各种操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>, (<span style=color:#a6e22e>photo</span>) =&gt; <span style=color:#a6e22e>handlePhoto</span>(<span style=color:#a6e22e>photo</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span></code></pre></div><p>随着程序越来越复杂，还有可能陷入到深层次嵌套的回调地狱（callback hell）中。按照惯例，应当避免两层以上的函数嵌套。</p><h2 id=promise>Promise<a hidden class=anchor aria-hidden=true href=#promise>#</a></h2><p>为了解决前面提到的回调地狱等问题，ES6中引入了<code>Promise</code>类型，利用<code>Promise</code>语法，可以轻松的将一个深度嵌套的回调函数改写成一种顺序的、更加易于理解的形式（即没有复杂的嵌套）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {            <span style=color:#75715e>// new 一个 Promise 类, 并向 Promise 类的构造器传递一个函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>, (<span style=color:#a6e22e>photo</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>photo</span>) {                                   <span style=color:#75715e>// 处理下载失败的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>reject</span>(<span style=color:#e6db74>&#39;Download Failed&#39;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>photo</span>)                            <span style=color:#75715e>// 处理下载成功的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>errorMessage</span> =&gt; {                             <span style=color:#75715e>// 如果下载失败, 执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>errorMessage</span>)
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>photo</span> =&gt; {                                     <span style=color:#75715e>// 如果下载成功, 继续执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>photo</span>
</span></span><span style=display:flex><span>}).<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>photo</span> =&gt; {                                    <span style=color:#75715e>// 如果上一部分执行成功, 继续执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>show</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>photo</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>phoyo</span> =&gt; {                                     <span style=color:#75715e>// 如果上一部分执行成功, 继续执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 其它各种操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span></code></pre></div><p><code>Promise</code>的用法也很简单，首先要使用new运算符实例化一个<code>Promise</code>对象，<code>Promise</code>类的构造器可以被用来包装任意一个返回值不是<code>Promise</code>类型的函数，如上面的第一行代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {            <span style=color:#75715e>// new 一个 Promise 对象, 并向 Promise 类的构造器传递了一个函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>, (<span style=color:#a6e22e>photo</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>photo</span>) {                                   <span style=color:#75715e>// 处理下载失败的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>reject</span>(<span style=color:#e6db74>&#39;Download Failed&#39;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>photo</span>)                            <span style=color:#75715e>// 处理下载成功的情况
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>上面向<code>Promise</code>构造器传递了一个具有两个参数的匿名函数，实际上也就等价于下面这段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Promise(<span style=color:#a6e22e>getPhoto</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getPhoto</span>(<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>downloadFile</span>(<span style=color:#e6db74>&#34;www.hello.com/test.png&#34;</span>, (<span style=color:#a6e22e>photo</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>photo</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>reject</span>(<span style=color:#e6db74>&#39;Download Failed&#39;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }) 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>简单的说，我们向<code>Promise</code>构造器传入了一个回调函数，该回调函数将被传入两个参数<code>resolve</code>和<code>reject</code>，下面来解释一下这两个参数的含义：</p><p>我们在做任何一件事情的过程中，都一定存在且只存在三种情况：</p><ul><li>这件事情尚未完成（还没开始 or 正在进行）</li><li>已经执行完成</li><li>执行失败</li></ul><blockquote><p>吃饭了吗？</p><p>还没吃/正在吃、吃完了、吃了，但吃到了奇怪的东西。</p></blockquote><p>前面我们已经把要做的事情（下载文件）包装到一个<code>Promise</code>对象里，那现在这个事情（<code>Promise</code>对象）执行到哪一步了呢？在<code>Promise</code>中，我们使用：</p><ul><li>pending（待定）</li><li>resolve（解决，或fulfilled）</li><li>reject（拒绝）</li></ul><p>来描述这三种状态，任意<code>Promise</code>对象的状态都一定是这三种状态之一。</p><p>这样，当使用<code>new</code>运算符创建一个新的<code>Promise</code>对象时，该对象的状态就是待定的<code>pending</code>状态；而如果执行了<code>resolve()</code>函数，<code>Promise</code>对象将转变为<code>fulfilled</code>状态，表明程序执行成功；同样的，如果调用<code>reject()</code>，则将转变为<code>reject</code>状态，表明程序执行失败。</p><p>那么改变<code>Promise</code>的状态又有什么效果呢？在前面的程序中，我们向<code>.then()</code>和<code>.catch()</code>方法各自传入了一个回调函数。如果<code>Promise</code>的状态变为<code>fulfilled</code>，就会执行传给<code>.then()</code>的函数；如果<code>Promise</code>的状态变为<code>reject</code>，就会执行传给<code>.catch()</code>的函数，这样就优雅的实现了异步函数的顺序执行，从而避免了回调函数的深层次嵌套。</p><p>接下来注意到，前面的程序在调用<code>resolve()</code>和<code>reject()</code>时，还向它们传递了参数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>photo</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>reject</span>(<span style=color:#e6db74>&#39;Download Failed&#39;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span><span style=color:#75715e>// ......
</span></span></span></code></pre></div><p>其实作用也很明显，传给<code>reject()</code>和<code>resolve()</code>的参数将作为回调函数的参数再次传递给紧跟其后的<code>.catch()</code>或<code>.then()</code>方法，所以才会有：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>errorMessage</span> =&gt; {         <span style=color:#75715e>// 如果下载失败, 执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>errorMessage</span>)
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>photo</span> =&gt; {                 <span style=color:#75715e>// 如果下载成功, 继续执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>photo</span>                  <span style=color:#75715e>// 将 photo 传递给下一个 .then() 方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>})
</span></span></code></pre></div><p>另外，<code>.then()</code>和<code>.catch()</code>方法还有一个重要的性质，即它们都会返回一个<code>Promise</code>对象，这样就可以随意的实现<code>Promise</code>的链式调用：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>photo</span> =&gt; {            <span style=color:#75715e>// 如果下载成功, 继续执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>photo</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>resize</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>photo</span>             <span style=color:#75715e>// 这里的 return 只是将 photo 作为回调函数的参数 (划重点) 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                             <span style=color:#75715e>// 传递给下一个 .then() 方法, 而 .then() 返回的仍然是 Promise 对象, 不是 photo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}).<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>photo</span> =&gt; {           <span style=color:#75715e>// 如果上一部分执行成功, 继续执行该语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>show</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>photo</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>photo</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>在使用<code>Promise</code>编写程序时，<code>.then()</code>和<code>.catch()</code>方法的调用顺序其实也有讲究，但这里就不对该问题做进一步讨论了。</p><p>最后还有一个问题，为什么<code>Promise</code>还允许用户传入一个用于异常处理的回调函数<code>reject()</code>，而不是让用户直接通过<code>try...catch()</code>来捕获异常？这个其实是因为在Javascript中，<code>try...catch()</code>语句块无法捕获异步回调中的异常：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Javascript data-lang=Javascript><span style=display:flex><span><span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>setTimeout</span>(<span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;You can not catch this error.&#39;</span>)
</span></span><span style=display:flex><span>    }, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>setTimeout()</code>内抛出的异常是无法被<code>try...catch()</code>直接捕获的。</p><h2 id=asyncawait>Async/Await<a hidden class=anchor aria-hidden=true href=#asyncawait>#</a></h2><p>Promise虽然已经解决了回调地狱的问题，但仍不够优雅————大量的<code>.then()</code>和<code>.catch()</code>语句块依然看着很傻。</p><p>于是，Javascript的设计者又设计出新的语法糖————<code>async</code>和<code>await</code>关键字。</p><p>待更。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuyangwang-git.github.io/tags/javascript/>Javascript</a></li><li><a href=https://yuyangwang-git.github.io/tags/async/>async</a></li></ul><nav class=paginav><a class=prev href=https://yuyangwang-git.github.io/posts/binary-search-notes/><span class=title>« Prev</span><br><span>二分查找的变化</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuyangwang-git.github.io>Yuyang Wang's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>