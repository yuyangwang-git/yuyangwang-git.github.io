<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>EFR32 入门笔记 2: 点亮 LED 灯 | Yuyang Wang's Blog</title><meta name=keywords content="C,EFR32"><meta name=description content="本文参考官方例程 Platform - Blink Bare-metal"><meta name=author content><link rel=canonical href=https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><link rel=icon href=https://wangyuyang.me/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://wangyuyang.me/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://wangyuyang.me/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://wangyuyang.me/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://wangyuyang.me/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/katex/katex.min.css><script defer src=/katex/katex.min.js></script><script defer src=/katex/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PG166B7MZ2"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PG166B7MZ2")}</script><meta property="og:url" content="https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/"><meta property="og:site_name" content="Yuyang Wang's Blog"><meta property="og:title" content="EFR32 入门笔记 2: 点亮 LED 灯"><meta property="og:description" content="本文参考官方例程 Platform - Blink Bare-metal"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-10T22:28:48+08:00"><meta property="article:modified_time" content="2023-03-10T22:28:48+08:00"><meta property="article:tag" content="C"><meta property="article:tag" content="EFR32"><meta property="og:image" content="https://wangyuyang.me/img/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://wangyuyang.me/img/cover.jpg"><meta name=twitter:title content="EFR32 入门笔记 2: 点亮 LED 灯"><meta name=twitter:description content="本文参考官方例程 Platform - Blink Bare-metal"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wangyuyang.me/posts/"},{"@type":"ListItem","position":2,"name":"EFR32 入门笔记 2: 点亮 LED 灯","item":"https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"EFR32 入门笔记 2: 点亮 LED 灯","name":"EFR32 入门笔记 2: 点亮 LED 灯","description":"本文参考官方例程 Platform - Blink Bare-metal","keywords":["C","EFR32"],"articleBody":"LED 闪烁程序 v1.0 —— 不使用定时器 创建一个 Empty C Project，其它文件不用动，直接修改 app.c 就行：\n// app.c #include \"em_cmu.h\" #include \"em_gpio.h\" typedef struct { GPIO_Port_TypeDef port; uint8_t pin; } LED; LED led_0; // LED 闪烁函数 // 通过循环实现延时 void led_blink(LED *led) { for (int i = 0; i \u003c 10000; i++) { GPIO_PinOutToggle(led-\u003eport, led-\u003epin); } } void app_init(void) { led_0.port = gpioPortA; led_0.pin = 1; CMU_ClockEnable(cmuClock_GPIO, true); // 开启 GPIO 时钟 GPIO_PinModeSet(led_0.port, led_0.pin, gpioModePushPull, 0); } void app_process_action(void) { led_blink(\u0026led_0); } 没啥好说的，很简单，GPIO 相关 API 可参考官方文档\nLED 闪烁程序 v2.0 —— 使用定时器 前面的程序采用循环来实现延时功能，不仅难以精确控制时间，阻塞式的代码也会显著降低系统的响应性，下面采用定时器来重写上述程序。\n这里不准备直接使用 EFR32 内部硬件 Timer，而选择 Gecko SDK 中提供的抽象程度更高的 Service —— Sleep Timer。\nThe Sleeptimer driver provides software timers, delays, timekeeping and date functionalities using a low-frequency real-time clock peripheral.\nAll Silicon Labs microcontrollers equipped with the RTC or RTCC peripheral are currently supported. Only one instance of this driver can be initialized by the application.\n— Sleep Timer Official Documents1\n在使用前，首先要在 Simplicity Studio 中安装 Sleep Timer Components：\n安装完成后，Project_DIR\\gecko_sdk_4.2.2\\platform\\service 文件夹下多了一个文件夹 sleeptimer\n接下来，修改 app.c 中的程序，其它文件保持不变：\n//app.c #include \"em_cmu.h\" #include \"em_gpio.h\" #include \"sl_sleeptimer.h\" // 增加头文件 typedef struct { GPIO_Port_TypeDef port; uint8_t pin; } LED; LED led_0; bool timeout_flag; unsigned int delay_ms; sl_sleeptimer_timer_handle_t timer; // Sleep Timer 超时回调函数 void timeout(sl_sleeptimer_timer_handle_t *handle, void *data) { (void)\u0026handle; // 因为我们的回调根本用不到这两个参数，如果不写这两行 (void)\u0026data; // 会提示 warning: unused parameter 'handle' 'data' timeout_flag = true; } void app_init(void) { led_0.port = gpioPortA; led_0.pin = 1; delay_ms = 500; CMU_ClockEnable(cmuClock_GPIO, true); // 开启 GPIO 时钟 GPIO_PinModeSet(led_0.port, led_0.pin, gpioModePushPull, 0); // 启用 sleep timer 定时器 sl_sleeptimer_start_periodic_timer_ms(\u0026timer, delay_ms, timeout, NULL, 0, SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG); } void app_process_action(void) { if (timeout_flag == true) { GPIO_PinOutToggle(led_0.port, led_0.pin); timeout_flag = false; } } 编译完成后，烧录程序，将看到 LED 灯闪烁。\n为什么没有手动初始化 Sleep Timer Service，程序就可以正确运行？ 笔者在直接调用 sl_sleeptimer_start_periodic_timer_ms() 函数时产生了上述疑问，于是带着疑问去翻阅了官方文档。根据官方文档，Sleep Timer 的初始化函数 sl_sleeptimer_init() 会在启动代码中被调用。\n那么我们回到 main.c 文件：\n// main.c ...... // Initialize Silicon Labs device, system, service(s) and protocol stack(s). // Note that if the kernel is present, processing task(s) will be created by // this call. sl_system_init(); ...... 继续查看 sl_system_init() 的实现：\n// sl_system_init.c #include \"sl_event_handler.h\" void sl_system_init(void) { sl_platform_init(); sl_driver_init(); sl_service_init(); // 这里有一行 service 初始化程序 sl_stack_init(); sl_internal_app_init(); } 继续查看 sl_service_init() 的实现：\n// sl_event_handler.c void sl_service_init(void) { sl_sleeptimer_init(); // 多了这一行 } 会发现 Simplicity Studio 已经在安装时帮我们增加了 Sleep Timer 的初始化代码，因此无需手动调用初始化函数 sl_sleeptimer_init()。\nLED 闪烁程序 v3.0 —— 优化项目结构 在这一节内容中，不打算给程序增加任何新功能，而是模仿 Gecko SDK Programming Model 的风格，重写前述程序。\n项目文件夹下新建文件：blink.c，blink.h：\n然后写入以下内容：\n// blink.h #ifndef BLINK_H #define BLINK_H void blink_init(void); void blink_process_action(void); #endif // BLINK_H // blink.c #include \"em_cmu.h\" #include \"em_gpio.h\" #include \"sl_sleeptimer.h\" typedef struct { GPIO_Port_TypeDef port; uint8_t pin; } LED; LED led_0; bool timeout_flag; unsigned int delay_ms; sl_sleeptimer_timer_handle_t timer; // Sleep Timer 超时回调函数 void timeout(sl_sleeptimer_timer_handle_t *handle, void *data) { (void)\u0026handle; // 因为我们的回调根本用不到这两个参数，如果不写这两行 (void)\u0026data; // 会提示 warning: unused parameter 'handle' 'data' timeout_flag = true; } void blink_init(void) { led_0.port = gpioPortA; led_0.pin = 1; delay_ms = 500; CMU_ClockEnable(cmuClock_GPIO, true); // 开启 GPIO 时钟 GPIO_PinModeSet(led_0.port, led_0.pin, gpioModePushPull, 0); // 启用 sleep timer 定时器 sl_sleeptimer_start_periodic_timer_ms(\u0026timer, delay_ms, timeout, NULL, 0, SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG); } void blink_process_action(void) { if (timeout_flag == true) { GPIO_PinOutToggle(led_0.port, led_0.pin); timeout_flag = false; } } 接着修改 app.c 文件：\n// app.c #include \"blink.h\" void app_init(void) { blink_init(); } void app_process_action(void) { blink_process_action(); // 有一点 RTOS 的感觉了 } 简单总结一下，app.c 和 app.h 是用户程序的顶层入口，考虑到每一个程序都可以拆分为若干子程序，这里将每个（本例仅一个）子程序单独形成文件，有点类似若干不同的“进程”。\n除了上述内容外，还可以做进一步的修改，待更。\nSleep Timer Official Documents. ↩︎\n","wordCount":"504","inLanguage":"en","image":"https://wangyuyang.me/img/cover.jpg","datePublished":"2023-03-10T22:28:48+08:00","dateModified":"2023-03-10T22:28:48+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/"},"publisher":{"@type":"Organization","name":"Yuyang Wang's Blog","logo":{"@type":"ImageObject","url":"https://wangyuyang.me/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wangyuyang.me/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://wangyuyang.me/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://wangyuyang.me/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://example.org title=Server><span>Server</span>&nbsp;
<svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://wangyuyang.me/>Home</a>&nbsp;»&nbsp;<a href=https://wangyuyang.me/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">EFR32 入门笔记 2: 点亮 LED 灯
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-description>本文参考官方例程 Platform - Blink Bare-metal</div><div class=post-meta><span title='2023-03-10 22:28:48 +0800 CST'>March 10, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;504 words</div></header><figure class=entry-cover><img loading=eager srcset='https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover_hu_1a9c99924ade04c4.jpg 360w,https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover_hu_f90106f74a601fac.jpg 480w,https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover_hu_ad02c0316b8a1473.jpg 720w,https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover_hu_98fc1d5546588df7.jpg 1080w,https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover_hu_b4eecf4ce8a84c7f.jpg 1500w,https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover.jpg 1920w' src=https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=1920 height=1272 alt></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#led-闪烁程序-v10--不使用定时器>LED 闪烁程序 v1.0 —— 不使用定时器</a></li><li><a href=#led-闪烁程序-v20--使用定时器>LED 闪烁程序 v2.0 —— 使用定时器</a><ul><li><a href=#为什么没有手动初始化-sleep-timer-service程序就可以正确运行>为什么没有手动初始化 Sleep Timer Service，程序就可以正确运行？</a></li></ul></li><li><a href=#led-闪烁程序-v30--优化项目结构>LED 闪烁程序 v3.0 —— 优化项目结构</a></li></ul></nav></div></details></div><div class=post-content><h2 id=led-闪烁程序-v10--不使用定时器>LED 闪烁程序 v1.0 —— 不使用定时器<a hidden class=anchor aria-hidden=true href=#led-闪烁程序-v10--不使用定时器>#</a></h2><p>创建一个 <code>Empty C Project</code>，其它文件不用动，直接修改 <code>app.c</code> 就行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// app.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_cmu.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_gpio.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GPIO_Port_TypeDef port;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> pin;
</span></span><span style=display:flex><span>} LED;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LED led_0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// LED 闪烁函数
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 通过循环实现延时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>led_blink</span>(LED <span style=color:#f92672>*</span>led)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10000</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>GPIO_PinOutToggle</span>(led<span style=color:#f92672>-&gt;</span>port, led<span style=color:#f92672>-&gt;</span>pin);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    led_0.port <span style=color:#f92672>=</span> gpioPortA;
</span></span><span style=display:flex><span>    led_0.pin <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_GPIO, true);                            <span style=color:#75715e>// 开启 GPIO 时钟
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>GPIO_PinModeSet</span>(led_0.port, led_0.pin, gpioModePushPull, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>led_blink</span>(<span style=color:#f92672>&amp;</span>led_0);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>没啥好说的，很简单，GPIO 相关 API 可参考<a href=https://docs.silabs.com/gecko-platform/4.2/emlib/api/efr32xg22/group-gpio>官方文档</a></p><h2 id=led-闪烁程序-v20--使用定时器>LED 闪烁程序 v2.0 —— 使用定时器<a hidden class=anchor aria-hidden=true href=#led-闪烁程序-v20--使用定时器>#</a></h2><p>前面的程序采用循环来实现延时功能，不仅难以精确控制时间，阻塞式的代码也会显著降低系统的响应性，下面采用定时器来重写上述程序。</p><p>这里不准备直接使用 EFR32 内部硬件 Timer，而选择 Gecko SDK 中提供的抽象程度更高的 Service —— Sleep Timer。</p><blockquote><p>The Sleeptimer driver provides software timers, delays, timekeeping and date functionalities using a low-frequency real-time clock peripheral.</p><p>All Silicon Labs microcontrollers equipped with the RTC or RTCC peripheral are currently supported. Only one instance of this driver can be initialized by the application.</p><p>— <cite>Sleep Timer Official Documents<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></cite></p></blockquote><p>在使用前，首先要在 Simplicity Studio 中安装 Sleep Timer Components：</p><p><img alt="Install Sleep Timer" loading=lazy src=/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/SleepTimer.png#center></p><p>安装完成后，<code>Project_DIR\gecko_sdk_4.2.2\platform\service</code> 文件夹下多了一个文件夹 <code>sleeptimer</code></p><p><img alt="Project Explorer" loading=lazy src=/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/ProjectExplorer.png#center></p><p>接下来，修改 <code>app.c</code> 中的程序，其它文件保持不变：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>//app.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_cmu.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_gpio.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;sl_sleeptimer.h&#34;   // 增加头文件</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GPIO_Port_TypeDef port;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> pin;
</span></span><span style=display:flex><span>} LED;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LED led_0;
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> timeout_flag;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> delay_ms;
</span></span><span style=display:flex><span><span style=color:#66d9ef>sl_sleeptimer_timer_handle_t</span> timer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Sleep Timer 超时回调函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>timeout</span>(<span style=color:#66d9ef>sl_sleeptimer_timer_handle_t</span> <span style=color:#f92672>*</span>handle, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>void</span>)<span style=color:#f92672>&amp;</span>handle;           <span style=color:#75715e>// 因为我们的回调根本用不到这两个参数，如果不写这两行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    (<span style=color:#66d9ef>void</span>)<span style=color:#f92672>&amp;</span>data;             <span style=color:#75715e>// 会提示 warning: unused parameter &#39;handle&#39; &#39;data&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    timeout_flag <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    led_0.port <span style=color:#f92672>=</span> gpioPortA;
</span></span><span style=display:flex><span>    led_0.pin <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    delay_ms <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_GPIO, true);                            <span style=color:#75715e>// 开启 GPIO 时钟
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>GPIO_PinModeSet</span>(led_0.port, led_0.pin, gpioModePushPull, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 启用 sleep timer 定时器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sl_sleeptimer_start_periodic_timer_ms</span>(<span style=color:#f92672>&amp;</span>timer, delay_ms, timeout, NULL, <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>                                          SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (timeout_flag <span style=color:#f92672>==</span> true)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>GPIO_PinOutToggle</span>(led_0.port, led_0.pin);
</span></span><span style=display:flex><span>        timeout_flag <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译完成后，烧录程序，将看到 LED 灯闪烁。</p><h3 id=为什么没有手动初始化-sleep-timer-service程序就可以正确运行>为什么没有手动初始化 Sleep Timer Service，程序就可以正确运行？<a hidden class=anchor aria-hidden=true href=#为什么没有手动初始化-sleep-timer-service程序就可以正确运行>#</a></h3><p>笔者在直接调用 <code>sl_sleeptimer_start_periodic_timer_ms()</code> 函数时产生了上述疑问，于是带着疑问去翻阅了官方文档。根据官方文档，Sleep Timer 的初始化函数 <code>sl_sleeptimer_init()</code> 会在启动代码中被调用。</p><p>那么我们回到 <code>main.c</code> 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// main.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Initialize Silicon Labs device, system, service(s) and protocol stack(s).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Note that if the kernel is present, processing task(s) will be created by
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// this call.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>sl_system_init</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>......
</span></span></code></pre></div><p>继续查看 <code>sl_system_init()</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// sl_system_init.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;sl_event_handler.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sl_system_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sl_platform_init</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sl_driver_init</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sl_service_init</span>();         <span style=color:#75715e>// 这里有一行 service 初始化程序
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>sl_stack_init</span>();
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sl_internal_app_init</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>继续查看 <code>sl_service_init()</code> 的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// sl_event_handler.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sl_service_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sl_sleeptimer_init</span>();      <span style=color:#75715e>// 多了这一行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>会发现 Simplicity Studio 已经在安装时帮我们增加了 Sleep Timer 的初始化代码，因此无需手动调用初始化函数 <code>sl_sleeptimer_init()</code>。</p><h2 id=led-闪烁程序-v30--优化项目结构>LED 闪烁程序 v3.0 —— 优化项目结构<a hidden class=anchor aria-hidden=true href=#led-闪烁程序-v30--优化项目结构>#</a></h2><p>在这一节内容中，不打算给程序增加任何新功能，而是模仿 Gecko SDK Programming Model 的风格，重写前述程序。</p><p>项目文件夹下新建文件：<code>blink.c</code>，<code>blink.h</code>：</p><p><img alt="Project Explorer" loading=lazy src=/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B02-%E7%82%B9%E4%BA%AEled%E7%81%AF/img/ProjectExplorer.png#center></p><p>然后写入以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// blink.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifndef BLINK_H
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define BLINK_H
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>blink_init</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>blink_process_action</span>(<span style=color:#66d9ef>void</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif </span><span style=color:#75715e>// BLINK_H
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// blink.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_cmu.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_gpio.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;sl_sleeptimer.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    GPIO_Port_TypeDef port;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint8_t</span> pin;
</span></span><span style=display:flex><span>} LED;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>LED led_0;
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> timeout_flag;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> delay_ms;
</span></span><span style=display:flex><span><span style=color:#66d9ef>sl_sleeptimer_timer_handle_t</span> timer;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Sleep Timer 超时回调函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>timeout</span>(<span style=color:#66d9ef>sl_sleeptimer_timer_handle_t</span> <span style=color:#f92672>*</span>handle, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>data)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>void</span>)<span style=color:#f92672>&amp;</span>handle;           <span style=color:#75715e>// 因为我们的回调根本用不到这两个参数，如果不写这两行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    (<span style=color:#66d9ef>void</span>)<span style=color:#f92672>&amp;</span>data;             <span style=color:#75715e>// 会提示 warning: unused parameter &#39;handle&#39; &#39;data&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    timeout_flag <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>blink_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    led_0.port <span style=color:#f92672>=</span> gpioPortA;
</span></span><span style=display:flex><span>    led_0.pin <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    delay_ms <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_GPIO, true);                            <span style=color:#75715e>// 开启 GPIO 时钟
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>GPIO_PinModeSet</span>(led_0.port, led_0.pin, gpioModePushPull, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 启用 sleep timer 定时器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sl_sleeptimer_start_periodic_timer_ms</span>(<span style=color:#f92672>&amp;</span>timer, delay_ms, timeout, NULL, <span style=color:#ae81ff>0</span>, 
</span></span><span style=display:flex><span>                                          SL_SLEEPTIMER_NO_HIGH_PRECISION_HF_CLOCKS_REQUIRED_FLAG);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>blink_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (timeout_flag <span style=color:#f92672>==</span> true)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>GPIO_PinOutToggle</span>(led_0.port, led_0.pin);
</span></span><span style=display:flex><span>        timeout_flag <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>接着修改 <code>app.c</code> 文件：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// app.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;blink.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blink_init</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blink_process_action</span>();            <span style=color:#75715e>// 有一点 RTOS 的感觉了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>简单总结一下，<code>app.c</code> 和 <code>app.h</code> 是用户程序的顶层入口，考虑到每一个程序都可以拆分为若干子程序，这里将每个（本例仅一个）子程序单独形成文件，有点类似若干不同的“进程”。</p><p>除了上述内容外，还可以做进一步的修改，待更。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.silabs.com/gecko-platform/latest/service/api/group-sleeptimer>Sleep Timer Official Documents</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wangyuyang.me/tags/c/>C</a></li><li><a href=https://wangyuyang.me/tags/efr32/>EFR32</a></li></ul><nav class=paginav><a class=prev href=https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B03-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/><span class=title>« Prev</span><br><span>EFR32 入门笔记 3: 串口通信</span>
</a><a class=next href=https://wangyuyang.me/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/><span class=title>Next »</span><br><span>EFR32 入门笔记 1: 开发环境搭建</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://wangyuyang.me/>Yuyang Wang's Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>