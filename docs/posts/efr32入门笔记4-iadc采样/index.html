<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>EFR32 入门笔记 4: IADC 采样 | Yuyang Wang's Blog</title><meta name=keywords content="C,EFR32"><meta name=description content="有手就行"><meta name=author content><link rel=canonical href=https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PG166B7MZ2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PG166B7MZ2",{anonymize_ip:!1})}</script><meta property="og:title" content="EFR32 入门笔记 4: IADC 采样"><meta property="og:description" content="有手就行"><meta property="og:type" content="article"><meta property="og:url" content="https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/"><meta property="og:image" content="https://yuyangwang-git.github.io/img/cover.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-15T16:32:30+08:00"><meta property="article:modified_time" content="2023-03-15T16:32:30+08:00"><meta property="og:site_name" content="Yuyang Wang's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yuyangwang-git.github.io/img/cover.jpg"><meta name=twitter:title content="EFR32 入门笔记 4: IADC 采样"><meta name=twitter:description content="有手就行"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yuyangwang-git.github.io/posts/"},{"@type":"ListItem","position":3,"name":"EFR32 入门笔记 4: IADC 采样","item":"https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"EFR32 入门笔记 4: IADC 采样","name":"EFR32 入门笔记 4: IADC 采样","description":"有手就行","keywords":["C","EFR32"],"articleBody":"IADC 外设 参考文档 AN1189: Incremental Analog to Digital Converter (IADC)\n按惯例，先安装必需的依赖包：\n和 USART 等外设不同，Sillicon Labs 并未给 IADC 提供相应的 Service 或 Driver，因此必须在底层外设库 emlib 上做开发。\n预备知识 IADC 有两种工作模式：Single Channel Mode 和 Scan Mode，前者仅转换一个通道（或者说引脚）上的信号，而后者可以转换多个通道上的信号。\nConversion results are written to the output data FIFO associated with the queue. Single queue results are written to the single data FIFO and scan queue results are written to the scan data FIFO. The two queues are identical in operation, but independent. Each FIFO can store up to four entries.\nADC 转换结果将会被写入到一个 FIFO 队列当中，该队列的容量为 4。\nThe SHOWID bit controls whether the conversion channel ID is included in the output data word. This option is primarily used with the scan FIFO to help software determine which channel each conversion result came from. If SHOWID is enabled for single conversions, the ID will always be set to 0x20.\n用户可以自行决定是否要为 ADC 转换结果增加一个 ID，该 ID 的作用是指示该结果是从哪个通道中读出的。而对于 Single Channel Mode，ID 将始终被设置为 0x20。\nIADC 输出结果的分辨率由两个参数 $OversamplingRatio$ 和 $DigitalAveraging$ 决定：\n$$ Output Resolution = 11 + log_2(OversamplingRatio \\times DigitalAveraging) $$\n$OversamplingRatio$ 为过采样比（OSR），提高过采样比可以改善 ADC 的积分非线性（INL）和微分非线性（DNL）误差，并减小噪声的影响——显然此时转换速度也会下降。该过程为一个模拟过程。\n$Digital Averaging$ 为移动平均，硬件会自动对转换结果（1、2、4、8 或 16 个采样结果）求平均值，求完均值后再将结果写入 FIFO 队列。该过程为一个数字过程。\n什么是微分非线性（differential nonlinearity）和积分非线性（integral nonlinearity）？\nAnalog-to-Digital Converter (ADC) Differential Non-Linearity (DNL) is defined as the maximum and minimum difference in the step width between the actual transfer function and the perfect transfer function. Non-linearity produces quantization steps with varying widths, some narrower and some wider.\nAnalog-to-Digital Converter (ADC) Integral Non-Linearity (INL) is defined as the maximum vertical difference between the actual and the ideal curve. It indicates the amount of deviation of the actual curve from the ideal transfer curve.\n— ADC Differential Non-linearity1\n基于轮询的使用方式 创建 Empty C Project，其它文件保持不变，app.c 填入以下内容：\n// app.c #include #include \"em_cmu.h\" #include \"em_iadc.h\" #define CLK_SRC_ADC_FREQ 20000000 // CLK_SRC_ADC #define CLK_ADC_FREQ 10000000 // CLK_ADC, ≤ 10 MHz, 根据 analog gain 调整 static volatile int32_t sample; static volatile double singleResult; void app_init(void) { // Initialization structures IADC_Init_t init = IADC_INIT_DEFAULT; IADC_AllConfigs_t initAllConfigs = IADC_ALLCONFIGS_DEFAULT; IADC_InitSingle_t initSingle = IADC_INITSINGLE_DEFAULT; init.srcClkPrescale = IADC_calcSrcClkPrescale(IADC0, CLK_SRC_ADC_FREQ, 0); // 计算 CLK_SRC_ADC 时钟信号的预分频比 init.warmup = iadcWarmupKeepWarm; initAllConfigs.configs[0].reference = iadcCfgReferenceInt1V2; // 采用内部 1.21V 基准源 initAllConfigs.configs[0].vRef = 1210; // 基准源电压 毫伏 initAllConfigs.configs[0].osrHighSpeed = iadcCfgOsrHighSpeed2x; // 2x 过采样率 initAllConfigs.configs[0].analogGain = iadcCfgAnalogGain0P5x; // 0.5x 输入增益 initAllConfigs.configs[0].adcClkPrescale = IADC_calcAdcClkPrescale(IADC0, CLK_ADC_FREQ, 0, iadcCfgModeNormal, init.srcClkPrescale); // 计算ADC_CLK 时钟信号的预分频比 // Single input structure IADC_SingleInput_t singleInput = IADC_SINGLEINPUT_DEFAULT; singleInput.posInput = iadcPosInputPortAPin0; // ADC 正输入引脚 singleInput.negInput = iadcNegInputGnd; // ADC 负输入引脚（单端测量直接接地） // Enable Clock CMU_ClockEnable(cmuClock_IADC0, true); CMU_ClockEnable(cmuClock_GPIO, true); CMU_ClockSelectSet(cmuClock_IADCCLK, cmuSelect_FSRCO); IADC_reset(IADC0); // Allocate the analog bus for ADC0 inputs // GPIO_ABUSALLOC, GPIO_BBUSALLOC, GPIO_CDBUSALLOC 对应 GPIO A, GPIO B, GPIO C // EVEN, ODD 对应偶数引脚，奇数引脚 // Single-End 模式可以使用任意引脚 // Differential 模式 positive input 必须为 even pin, negative input 必须为 odd pin // 例如, Single-End 下使用 PB 1 作为输入，则此处配置为: GPIO-\u003eBBUSALLOC |= GPIO_BBUSALLOC_BODD0_ADC0 GPIO-\u003eABUSALLOC |= GPIO_ABUSALLOC_AEVEN0_ADC0; // Initialize IADC // Initialize a single-channel conversion IADC_init(IADC0, \u0026init, \u0026initAllConfigs); IADC_initSingle(IADC0, \u0026initSingle, \u0026singleInput); } void app_process_action(void) { IADC_command(IADC0, iadcCmdStartSingle); // 等待 ADC 转换完成 if ((IADC0-\u003eSTATUS \u0026 (_IADC_STATUS_CONVERTING_MASK | _IADC_STATUS_SINGLEFIFODV_MASK)) != IADC_STATUS_SINGLEFIFODV) { ; } else { // 转换完成 sample = IADC_pullSingleFifoResult(IADC0).data; singleResult = (sample / 0xFFF) * (1.21 / 0.5); printf(\"x=%lu\\r\\n\", sample); } } 基于中断的使用方式 先放源码：\n// app.c #include #include \"em_cmu.h\" #include \"em_emu.h\" // 增加 EMU, 降低系统能耗 #include \"em_iadc.h\" #define CLK_SRC_ADC_FREQ 20000000 // CLK_SRC_ADC #define CLK_ADC_FREQ 10000000 // CLK_ADC, ≤ 10 MHz, 根据 analog gain 调整 static volatile int32_t sample; static volatile double singleResult; void app_init(void) { // Initialization structures IADC_Init_t init = IADC_INIT_DEFAULT; IADC_AllConfigs_t initAllConfigs = IADC_ALLCONFIGS_DEFAULT; IADC_InitSingle_t initSingle = IADC_INITSINGLE_DEFAULT; init.srcClkPrescale = IADC_calcSrcClkPrescale(IADC0, CLK_SRC_ADC_FREQ, 0); // 计算 CLK_SRC_ADC 时钟信号的预分频比 init.warmup = iadcWarmupKeepWarm; initAllConfigs.configs[0].reference = iadcCfgReferenceInt1V2; // 采用内部 1.21V 基准源 initAllConfigs.configs[0].vRef = 1210; // 基准源电压 毫伏 initAllConfigs.configs[0].osrHighSpeed = iadcCfgOsrHighSpeed2x; // 2x 过采样率 initAllConfigs.configs[0].analogGain = iadcCfgAnalogGain0P5x; // 0.5x 输入增益 initAllConfigs.configs[0].adcClkPrescale = IADC_calcAdcClkPrescale(IADC0, CLK_ADC_FREQ, 0, iadcCfgModeNormal, init.srcClkPrescale); // 计算ADC_CLK 时钟信号的预分频比 // Single input structure IADC_SingleInput_t singleInput = IADC_SINGLEINPUT_DEFAULT; singleInput.posInput = iadcPosInputPortAPin0; // ADC 正输入引脚 singleInput.negInput = iadcNegInputGnd; // ADC 负输入引脚（单端测量直接接地） // Enable Clock CMU_ClockEnable(cmuClock_IADC0, true); CMU_ClockEnable(cmuClock_GPIO, true); // Use the FSRC0 as the IADC clock so it can run in EM2 CMU_ClockSelectSet(cmuClock_IADCCLK, cmuSelect_FSRCO); IADC_reset(IADC0); // Allocate the analog bus for ADC0 inputs // GPIO_ABUSALLOC, GPIO_BBUSALLOC, GPIO_CDBUSALLOC 对应 GPIO A, GPIO B, GPIO C // EVEN, ODD 对应偶数引脚，奇数引脚 // Single-End 模式可以使用任意引脚 // Differential 模式 positive input 必须为 even pin, negative input 必须为 odd pin // 例如, Single-End 下使用 PB 1 作为输入，则此处配置为: GPIO-\u003eBBUSALLOC |= GPIO_BBUSALLOC_BODD0_ADC0 GPIO-\u003eABUSALLOC |= GPIO_ABUSALLOC_AEVEN0_ADC0; // Initialize IADC // Initialize a single-channel conversion IADC_init(IADC0, \u0026init, \u0026initAllConfigs); IADC_initSingle(IADC0, \u0026initSingle, \u0026singleInput); // Clear any previous interrupt flags IADC_clearInt(IADC0, _IADC_IF_MASK); // Enable single-channel done interrupts IADC_enableInt(IADC0, IADC_IEN_SINGLEDONE); // Enable IADC interrupts NVIC_ClearPendingIRQ(IADC_IRQn); NVIC_EnableIRQ(IADC_IRQn); } void app_process_action(void) { IADC_command(IADC0, iadcCmdStartSingle); EMU_EnterEM2(false); // 进入 EM2 模式等待转换完成 // or EMU_EnterEM1(); printf(\"x=%lu\\r\\n\", sample); } void IADC_IRQHandler(void) { sample = IADC_pullSingleFifoResult(IADC0).data; singleResult = (sample / 0xFFF) * (1.21 / 0.5); IADC_clearInt(IADC0, IADC_IF_SINGLEDONE); } 这里其实主要增加了以下几行：\n#include \"em_emu.h\" 没啥好说的，目的是为了调用 EMU_EnterEM2() 函数。\n// Clear any previous interrupt flags IADC_clearInt(IADC0, _IADC_IF_MASK); // Enable single-channel done interrupts IADC_enableInt(IADC0, IADC_IEN_SINGLEDONE); // Enable IADC interrupts NVIC_ClearPendingIRQ(IADC_IRQn); NVIC_EnableIRQ(IADC_IRQn); 开启中断，常规操作了。\nvoid app_process_action(void) { IADC_command(IADC0, iadcCmdStartSingle); EMU_EnterEM2(false); // 进入 EM2 模式等待转换完成 // or EMU_EnterEM1(); printf(\"x=%lu\\r\\n\", sample); } void IADC_IRQHandler(void) { sample = IADC_pullSingleFifoResult(IADC0).data; singleResult = (sample / 0xFFF) * (1.21 / 0.5); IADC_clearInt(IADC0, IADC_IF_SINGLEDONE); } 中断处理函数也没啥好说的，中断列表全写在设备头文件 efr32bg22c112f352gm32.h 里：\n// efr32bg22c112f352gm32.h /** Interrupt Number Definition */ typedef enum IRQn{ /****** Cortex-M Processor Exceptions Numbers ******************************************/ NonMaskableInt_IRQn = -14, /*!\u003c -14 Cortex-M Non Maskable Interrupt */ HardFault_IRQn = -13, /*!\u003c -13 Cortex-M Hard Fault Interrupt */ MemoryManagement_IRQn = -12, /*!\u003c -12 Cortex-M Memory Management Interrupt */ BusFault_IRQn = -11, /*!\u003c -11 Cortex-M Bus Fault Interrupt */ UsageFault_IRQn = -10, /*!\u003c -10 Cortex-M Usage Fault Interrupt */ SVCall_IRQn = -5, /*!\u003c -5 Cortex-M SV Call Interrupt */ DebugMonitor_IRQn = -4, /*!\u003c -4 Cortex-M Debug Monitor Interrupt */ PendSV_IRQn = -2, /*!\u003c -2 Cortex-M Pend SV Interrupt */ SysTick_IRQn = -1, /*!\u003c -1 Cortex-M System Tick Interrupt */ /****** EFR32BG22 Peripheral Interrupt Numbers ******************************************/ CRYPTOACC_IRQn = 0, /*!\u003c 0 EFR32 CRYPTOACC Interrupt */ TRNG_IRQn = 1, /*!\u003c 1 EFR32 TRNG Interrupt */ PKE_IRQn = 2, /*!\u003c 2 EFR32 PKE Interrupt */ SMU_SECURE_IRQn = 3, /*!\u003c 3 EFR32 SMU_SECURE Interrupt */ SMU_S_PRIVILEGED_IRQn = 4, /*!\u003c 4 EFR32 SMU_S_PRIVILEGED Interrupt */ SMU_NS_PRIVILEGED_IRQn = 5, /*!\u003c 5 EFR32 SMU_NS_PRIVILEGED Interrupt */ EMU_IRQn = 6, /*!\u003c 6 EFR32 EMU Interrupt */ TIMER0_IRQn = 7, /*!\u003c 7 EFR32 TIMER0 Interrupt */ TIMER1_IRQn = 8, /*!\u003c 8 EFR32 TIMER1 Interrupt */ TIMER2_IRQn = 9, /*!\u003c 9 EFR32 TIMER2 Interrupt */ TIMER3_IRQn = 10, /*!\u003c 10 EFR32 TIMER3 Interrupt */ TIMER4_IRQn = 11, /*!\u003c 11 EFR32 TIMER4 Interrupt */ RTCC_IRQn = 12, /*!\u003c 12 EFR32 RTCC Interrupt */ USART0_RX_IRQn = 13, /*!\u003c 13 EFR32 USART0_RX Interrupt */ USART0_TX_IRQn = 14, /*!\u003c 14 EFR32 USART0_TX Interrupt */ USART1_RX_IRQn = 15, /*!\u003c 15 EFR32 USART1_RX Interrupt */ USART1_TX_IRQn = 16, /*!\u003c 16 EFR32 USART1_TX Interrupt */ ICACHE0_IRQn = 17, /*!\u003c 17 EFR32 ICACHE0 Interrupt */ BURTC_IRQn = 18, /*!\u003c 18 EFR32 BURTC Interrupt */ LETIMER0_IRQn = 19, /*!\u003c 19 EFR32 LETIMER0 Interrupt */ SYSCFG_IRQn = 20, /*!\u003c 20 EFR32 SYSCFG Interrupt */ LDMA_IRQn = 21, /*!\u003c 21 EFR32 LDMA Interrupt */ LFXO_IRQn = 22, /*!\u003c 22 EFR32 LFXO Interrupt */ LFRCO_IRQn = 23, /*!\u003c 23 EFR32 LFRCO Interrupt */ ULFRCO_IRQn = 24, /*!\u003c 24 EFR32 ULFRCO Interrupt */ GPIO_ODD_IRQn = 25, /*!\u003c 25 EFR32 GPIO_ODD Interrupt */ GPIO_EVEN_IRQn = 26, /*!\u003c 26 EFR32 GPIO_EVEN Interrupt */ I2C0_IRQn = 27, /*!\u003c 27 EFR32 I2C0 Interrupt */ I2C1_IRQn = 28, /*!\u003c 28 EFR32 I2C1 Interrupt */ EMUDG_IRQn = 29, /*!\u003c 29 EFR32 EMUDG Interrupt */ EMUSE_IRQn = 30, /*!\u003c 30 EFR32 EMUSE Interrupt */ AGC_IRQn = 31, /*!\u003c 31 EFR32 AGC Interrupt */ BUFC_IRQn = 32, /*!\u003c 32 EFR32 BUFC Interrupt */ FRC_PRI_IRQn = 33, /*!\u003c 33 EFR32 FRC_PRI Interrupt */ FRC_IRQn = 34, /*!\u003c 34 EFR32 FRC Interrupt */ MODEM_IRQn = 35, /*!\u003c 35 EFR32 MODEM Interrupt */ PROTIMER_IRQn = 36, /*!\u003c 36 EFR32 PROTIMER Interrupt */ RAC_RSM_IRQn = 37, /*!\u003c 37 EFR32 RAC_RSM Interrupt */ RAC_SEQ_IRQn = 38, /*!\u003c 38 EFR32 RAC_SEQ Interrupt */ RDMAILBOX_IRQn = 39, /*!\u003c 39 EFR32 RDMAILBOX Interrupt */ RFSENSE_IRQn = 40, /*!\u003c 40 EFR32 RFSENSE Interrupt */ PRORTC_IRQn = 41, /*!\u003c 41 EFR32 PRORTC Interrupt */ SYNTH_IRQn = 42, /*!\u003c 42 EFR32 SYNTH Interrupt */ WDOG0_IRQn = 43, /*!\u003c 43 EFR32 WDOG0 Interrupt */ HFXO0_IRQn = 44, /*!\u003c 44 EFR32 HFXO0 Interrupt */ HFRCO0_IRQn = 45, /*!\u003c 45 EFR32 HFRCO0 Interrupt */ CMU_IRQn = 46, /*!\u003c 46 EFR32 CMU Interrupt */ AES_IRQn = 47, /*!\u003c 47 EFR32 AES Interrupt */ IADC_IRQn = 48, /*!\u003c 48 EFR32 IADC Interrupt */ MSC_IRQn = 49, /*!\u003c 49 EFR32 MSC Interrupt */ DPLL0_IRQn = 50, /*!\u003c 50 EFR32 DPLL0 Interrupt */ PDM_IRQn = 51, /*!\u003c 51 EFR32 PDM Interrupt */ SW0_IRQn = 52, /*!\u003c 52 EFR32 SW0 Interrupt */ SW1_IRQn = 53, /*!\u003c 53 EFR32 SW1 Interrupt */ SW2_IRQn = 54, /*!\u003c 54 EFR32 SW2 Interrupt */ SW3_IRQn = 55, /*!\u003c 55 EFR32 SW3 Interrupt */ KERNEL0_IRQn = 56, /*!\u003c 56 EFR32 KERNEL0 Interrupt */ KERNEL1_IRQn = 57, /*!\u003c 57 EFR32 KERNEL1 Interrupt */ M33CTI0_IRQn = 58, /*!\u003c 58 EFR32 M33CTI0 Interrupt */ M33CTI1_IRQn = 59, /*!\u003c 59 EFR32 M33CTI1 Interrupt */ EMUEFP_IRQn = 60, /*!\u003c 60 EFR32 EMUEFP Interrupt */ DCDC_IRQn = 61, /*!\u003c 61 EFR32 DCDC Interrupt */ EUART0_RX_IRQn = 62, /*!\u003c 62 EFR32 EUART0_RX Interrupt */ EUART0_TX_IRQn = 63, /*!\u003c 63 EFR32 EUART0_TX Interrupt */ } IRQn_Type; ADC Differential Non-linearity - Microchip Developer Helper. ↩︎\n","wordCount":"1534","inLanguage":"en","image":"https://yuyangwang-git.github.io/img/cover.jpg","datePublished":"2023-03-15T16:32:30+08:00","dateModified":"2023-03-15T16:32:30+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/"},"publisher":{"@type":"Organization","name":"Yuyang Wang's Blog","logo":{"@type":"ImageObject","url":"https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuyangwang-git.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuyangwang-git.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yuyangwang-git.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://example.org title=Server><span>Server</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yuyangwang-git.github.io>Home</a>&nbsp;»&nbsp;<a href=https://yuyangwang-git.github.io/posts/>Posts</a></div><h1 class=post-title>EFR32 入门笔记 4: IADC 采样</h1><div class=post-description>有手就行</div><div class=post-meta><span title='2023-03-15 16:32:30 +0800 CST'>March 15, 2023</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;1534 words</div></header><figure class=entry-cover><img loading=lazy srcset="https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover_hua3d40a19c8067b2bf5017020ca9c877b_137661_360x0_resize_q75_box.jpg 360w ,https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover_hua3d40a19c8067b2bf5017020ca9c877b_137661_480x0_resize_q75_box.jpg 480w ,https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover_hua3d40a19c8067b2bf5017020ca9c877b_137661_720x0_resize_q75_box.jpg 720w ,https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover_hua3d40a19c8067b2bf5017020ca9c877b_137661_1080x0_resize_q75_box.jpg 1080w ,https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover_hua3d40a19c8067b2bf5017020ca9c877b_137661_1500x0_resize_q75_box.jpg 1500w ,https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover.jpg 1920w" sizes="(min-width: 768px) 720px, 100vw" src=https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B04-iadc%E9%87%87%E6%A0%B7/img/cover.jpg alt width=1920 height=1272></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#iadc-外设>IADC 外设</a><ul><li><a href=#预备知识>预备知识</a></li><li><a href=#基于轮询的使用方式>基于轮询的使用方式</a></li></ul></li><li><a href=#基于中断的使用方式>基于中断的使用方式</a></li></ul></nav></div></details></div><div class=post-content><h2 id=iadc-外设>IADC 外设<a hidden class=anchor aria-hidden=true href=#iadc-外设>#</a></h2><p>参考文档 <a href=https://www.silabs.com/documents/public/application-notes/an1189-efr32-iadc.pdf>AN1189: Incremental Analog to Digital Converter (IADC)</a></p><p>按惯例，先安装必需的依赖包：</p><p><img loading=lazy src=img/IADC.jpg#center alt=IADC></p><p>和 USART 等外设不同，Sillicon Labs 并未给 IADC 提供相应的 Service 或 Driver，因此必须在底层外设库 <code>emlib</code> 上做开发。</p><h3 id=预备知识>预备知识<a hidden class=anchor aria-hidden=true href=#预备知识>#</a></h3><p>IADC 有两种工作模式：Single Channel Mode 和 Scan Mode，前者仅转换一个通道（或者说引脚）上的信号，而后者可以转换多个通道上的信号。</p><blockquote><p>Conversion results are written to the output data FIFO associated with the queue. Single queue results are written to the single data FIFO and scan queue results are written to the scan data FIFO. The two queues are identical in operation, but independent. Each FIFO can store up to four entries.</p></blockquote><p>ADC 转换结果将会被写入到一个 FIFO 队列当中，该队列的容量为 4。</p><blockquote><p>The SHOWID bit controls whether the conversion channel ID is included in the output data word. This option is primarily used with the scan FIFO to help software determine which channel each conversion result came from. If SHOWID is enabled for single conversions, the ID will always be set to 0x20.</p></blockquote><p>用户可以自行决定是否要为 ADC 转换结果增加一个 ID，该 ID 的作用是指示该结果是从哪个通道中读出的。而对于 Single Channel Mode，ID 将始终被设置为 0x20。</p><p>IADC 输出结果的分辨率由两个参数 $OversamplingRatio$ 和 $DigitalAveraging$ 决定：</p><p>$$
Output Resolution = 11 + log_2(OversamplingRatio \times DigitalAveraging)
$$</p><p>$OversamplingRatio$ 为过采样比（OSR），提高过采样比可以改善 ADC 的积分非线性（INL）和微分非线性（DNL）误差，并减小噪声的影响——显然此时转换速度也会下降。该过程为一个模拟过程。</p><p>$Digital Averaging$ 为移动平均，硬件会自动对转换结果（1、2、4、8 或 16 个采样结果）求平均值，求完均值后再将结果写入 FIFO 队列。该过程为一个数字过程。</p><blockquote><p>什么是微分非线性（differential nonlinearity）和积分非线性（integral nonlinearity）？</p><p>Analog-to-Digital Converter (ADC) Differential Non-Linearity (DNL) is defined as the maximum and minimum difference in the step width between the actual transfer function and the perfect transfer function. Non-linearity produces quantization steps with varying widths, some narrower and some wider.</p><p><img loading=lazy src=img/ADCDNL.png#center alt="ADC DNL"></p><p>Analog-to-Digital Converter (ADC) Integral Non-Linearity (INL) is defined as the maximum vertical difference between the actual and the ideal curve. It indicates the amount of deviation of the actual curve from the ideal transfer curve.</p><p><img loading=lazy src=img/ADCINL.png#center alt="ADC INL"></p><p>— ADC Differential Non-linearity<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><h3 id=基于轮询的使用方式>基于轮询的使用方式<a hidden class=anchor aria-hidden=true href=#基于轮询的使用方式>#</a></h3><p>创建 <code>Empty C Project</code>，其它文件保持不变，<code>app.c</code> 填入以下内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// app.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_cmu.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_iadc.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define CLK_SRC_ADC_FREQ        20000000  </span><span style=color:#75715e>// CLK_SRC_ADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define CLK_ADC_FREQ            10000000  </span><span style=color:#75715e>// CLK_ADC, ≤ 10 MHz, 根据 analog gain 调整
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int32_t</span> sample;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>double</span> singleResult;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialization structures
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    IADC_Init_t init <span style=color:#f92672>=</span> IADC_INIT_DEFAULT;
</span></span><span style=display:flex><span>    IADC_AllConfigs_t initAllConfigs <span style=color:#f92672>=</span> IADC_ALLCONFIGS_DEFAULT;
</span></span><span style=display:flex><span>    IADC_InitSingle_t initSingle <span style=color:#f92672>=</span> IADC_INITSINGLE_DEFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    init.srcClkPrescale <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_calcSrcClkPrescale</span>(IADC0, CLK_SRC_ADC_FREQ, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 计算 CLK_SRC_ADC 时钟信号的预分频比
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    init.warmup <span style=color:#f92672>=</span> iadcWarmupKeepWarm;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].reference <span style=color:#f92672>=</span> iadcCfgReferenceInt1V2;              <span style=color:#75715e>// 采用内部 1.21V 基准源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].vRef <span style=color:#f92672>=</span> <span style=color:#ae81ff>1210</span>;                                     <span style=color:#75715e>// 基准源电压 毫伏
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].osrHighSpeed <span style=color:#f92672>=</span> iadcCfgOsrHighSpeed2x;            <span style=color:#75715e>// 2x 过采样率
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].analogGain <span style=color:#f92672>=</span> iadcCfgAnalogGain0P5x;              <span style=color:#75715e>// 0.5x 输入增益
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].adcClkPrescale <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_calcAdcClkPrescale</span>(IADC0, CLK_ADC_FREQ,
</span></span><span style=display:flex><span>                                                                       <span style=color:#ae81ff>0</span>, iadcCfgModeNormal,
</span></span><span style=display:flex><span>                                                                       init.srcClkPrescale);  <span style=color:#75715e>// 计算ADC_CLK 时钟信号的预分频比
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Single input structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    IADC_SingleInput_t singleInput <span style=color:#f92672>=</span> IADC_SINGLEINPUT_DEFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    singleInput.posInput <span style=color:#f92672>=</span> iadcPosInputPortAPin0;          <span style=color:#75715e>// ADC 正输入引脚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    singleInput.negInput <span style=color:#f92672>=</span> iadcNegInputGnd;                <span style=color:#75715e>// ADC 负输入引脚（单端测量直接接地）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enable Clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_IADC0, true);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_GPIO, true);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CMU_ClockSelectSet</span>(cmuClock_IADCCLK, cmuSelect_FSRCO);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_reset</span>(IADC0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Allocate the analog bus for ADC0 inputs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// GPIO_ABUSALLOC, GPIO_BBUSALLOC, GPIO_CDBUSALLOC 对应 GPIO A, GPIO B, GPIO C
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// EVEN, ODD 对应偶数引脚，奇数引脚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Single-End 模式可以使用任意引脚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Differential 模式 positive input 必须为 even pin, negative input 必须为 odd pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 例如, Single-End 下使用 PB 1 作为输入，则此处配置为: GPIO-&gt;BBUSALLOC |= GPIO_BBUSALLOC_BODD0_ADC0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    GPIO<span style=color:#f92672>-&gt;</span>ABUSALLOC <span style=color:#f92672>|=</span> GPIO_ABUSALLOC_AEVEN0_ADC0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize IADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Initialize a single-channel conversion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>IADC_init</span>(IADC0, <span style=color:#f92672>&amp;</span>init, <span style=color:#f92672>&amp;</span>initAllConfigs);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_initSingle</span>(IADC0, <span style=color:#f92672>&amp;</span>initSingle, <span style=color:#f92672>&amp;</span>singleInput);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_command</span>(IADC0, iadcCmdStartSingle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 等待 ADC 转换完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> ((IADC0<span style=color:#f92672>-&gt;</span>STATUS <span style=color:#f92672>&amp;</span> (_IADC_STATUS_CONVERTING_MASK <span style=color:#f92672>|</span> _IADC_STATUS_SINGLEFIFODV_MASK)) <span style=color:#f92672>!=</span> IADC_STATUS_SINGLEFIFODV)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 转换完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        sample <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_pullSingleFifoResult</span>(IADC0).data;
</span></span><span style=display:flex><span>        singleResult <span style=color:#f92672>=</span> (sample <span style=color:#f92672>/</span> <span style=color:#ae81ff>0xFFF</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.21</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;x=%lu</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, sample);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=基于中断的使用方式>基于中断的使用方式<a hidden class=anchor aria-hidden=true href=#基于中断的使用方式>#</a></h2><p>先放源码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// app.c
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_cmu.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_emu.h&#34;                         // 增加 EMU, 降低系统能耗</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_iadc.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define CLK_SRC_ADC_FREQ        20000000    </span><span style=color:#75715e>// CLK_SRC_ADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define CLK_ADC_FREQ            10000000    </span><span style=color:#75715e>// CLK_ADC, ≤ 10 MHz, 根据 analog gain 调整
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>int32_t</span> sample;
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>double</span> singleResult;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_init</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialization structures
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    IADC_Init_t init <span style=color:#f92672>=</span> IADC_INIT_DEFAULT;
</span></span><span style=display:flex><span>    IADC_AllConfigs_t initAllConfigs <span style=color:#f92672>=</span> IADC_ALLCONFIGS_DEFAULT;
</span></span><span style=display:flex><span>    IADC_InitSingle_t initSingle <span style=color:#f92672>=</span> IADC_INITSINGLE_DEFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    init.srcClkPrescale <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_calcSrcClkPrescale</span>(IADC0, CLK_SRC_ADC_FREQ, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>// 计算 CLK_SRC_ADC 时钟信号的预分频比
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    init.warmup <span style=color:#f92672>=</span> iadcWarmupKeepWarm;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].reference <span style=color:#f92672>=</span> iadcCfgReferenceInt1V2;              <span style=color:#75715e>// 采用内部 1.21V 基准源
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].vRef <span style=color:#f92672>=</span> <span style=color:#ae81ff>1210</span>;                                     <span style=color:#75715e>// 基准源电压 毫伏
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].osrHighSpeed <span style=color:#f92672>=</span> iadcCfgOsrHighSpeed2x;            <span style=color:#75715e>// 2x 过采样率
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].analogGain <span style=color:#f92672>=</span> iadcCfgAnalogGain0P5x;              <span style=color:#75715e>// 0.5x 输入增益
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    initAllConfigs.configs[<span style=color:#ae81ff>0</span>].adcClkPrescale <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_calcAdcClkPrescale</span>(IADC0, CLK_ADC_FREQ,
</span></span><span style=display:flex><span>                                                                       <span style=color:#ae81ff>0</span>, iadcCfgModeNormal,
</span></span><span style=display:flex><span>                                                                       init.srcClkPrescale);  <span style=color:#75715e>// 计算ADC_CLK 时钟信号的预分频比
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Single input structure
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    IADC_SingleInput_t singleInput <span style=color:#f92672>=</span> IADC_SINGLEINPUT_DEFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    singleInput.posInput <span style=color:#f92672>=</span> iadcPosInputPortAPin0;          <span style=color:#75715e>// ADC 正输入引脚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    singleInput.negInput <span style=color:#f92672>=</span> iadcNegInputGnd;                <span style=color:#75715e>// ADC 负输入引脚（单端测量直接接地）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enable Clock
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_IADC0, true);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CMU_ClockEnable</span>(cmuClock_GPIO, true);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Use the FSRC0 as the IADC clock so it can run in EM2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>CMU_ClockSelectSet</span>(cmuClock_IADCCLK, cmuSelect_FSRCO);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_reset</span>(IADC0);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Allocate the analog bus for ADC0 inputs
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// GPIO_ABUSALLOC, GPIO_BBUSALLOC, GPIO_CDBUSALLOC 对应 GPIO A, GPIO B, GPIO C
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// EVEN, ODD 对应偶数引脚，奇数引脚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Single-End 模式可以使用任意引脚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Differential 模式 positive input 必须为 even pin, negative input 必须为 odd pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 例如, Single-End 下使用 PB 1 作为输入，则此处配置为: GPIO-&gt;BBUSALLOC |= GPIO_BBUSALLOC_BODD0_ADC0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    GPIO<span style=color:#f92672>-&gt;</span>ABUSALLOC <span style=color:#f92672>|=</span> GPIO_ABUSALLOC_AEVEN0_ADC0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Initialize IADC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Initialize a single-channel conversion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>IADC_init</span>(IADC0, <span style=color:#f92672>&amp;</span>init, <span style=color:#f92672>&amp;</span>initAllConfigs);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_initSingle</span>(IADC0, <span style=color:#f92672>&amp;</span>initSingle, <span style=color:#f92672>&amp;</span>singleInput);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Clear any previous interrupt flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>IADC_clearInt</span>(IADC0, _IADC_IF_MASK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enable single-channel done interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>IADC_enableInt</span>(IADC0, IADC_IEN_SINGLEDONE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Enable IADC interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>NVIC_ClearPendingIRQ</span>(IADC_IRQn);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>NVIC_EnableIRQ</span>(IADC_IRQn);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_command</span>(IADC0, iadcCmdStartSingle);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>EMU_EnterEM2</span>(false);                         <span style=color:#75715e>// 进入 EM2 模式等待转换完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or EMU_EnterEM1();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;x=%lu</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, sample);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>IADC_IRQHandler</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sample <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_pullSingleFifoResult</span>(IADC0).data;
</span></span><span style=display:flex><span>    singleResult <span style=color:#f92672>=</span> (sample <span style=color:#f92672>/</span> <span style=color:#ae81ff>0xFFF</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.21</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_clearInt</span>(IADC0, IADC_IF_SINGLEDONE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里其实主要增加了以下几行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;em_emu.h&#34;</span><span style=color:#75715e>
</span></span></span></code></pre></div><p>没啥好说的，目的是为了调用 <code>EMU_EnterEM2()</code> 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// Clear any previous interrupt flags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>IADC_clearInt</span>(IADC0, _IADC_IF_MASK);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Enable single-channel done interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>IADC_enableInt</span>(IADC0, IADC_IEN_SINGLEDONE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Enable IADC interrupts
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>NVIC_ClearPendingIRQ</span>(IADC_IRQn);
</span></span><span style=display:flex><span><span style=color:#a6e22e>NVIC_EnableIRQ</span>(IADC_IRQn);
</span></span></code></pre></div><p>开启中断，常规操作了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>app_process_action</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_command</span>(IADC0, iadcCmdStartSingle);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>EMU_EnterEM2</span>(false);                         <span style=color:#75715e>// 进入 EM2 模式等待转换完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or EMU_EnterEM1();
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;x=%lu</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>, sample);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>IADC_IRQHandler</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sample <span style=color:#f92672>=</span> <span style=color:#a6e22e>IADC_pullSingleFifoResult</span>(IADC0).data;
</span></span><span style=display:flex><span>    singleResult <span style=color:#f92672>=</span> (sample <span style=color:#f92672>/</span> <span style=color:#ae81ff>0xFFF</span>) <span style=color:#f92672>*</span> (<span style=color:#ae81ff>1.21</span> <span style=color:#f92672>/</span> <span style=color:#ae81ff>0.5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IADC_clearInt</span>(IADC0, IADC_IF_SINGLEDONE);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>中断处理函数也没啥好说的，中断列表全写在设备头文件 <code>efr32bg22c112f352gm32.h</code> 里：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>// efr32bg22c112f352gm32.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** Interrupt Number Definition */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>enum</span> IRQn{
</span></span><span style=display:flex><span>  <span style=color:#75715e>/******  Cortex-M Processor Exceptions Numbers ******************************************/</span>
</span></span><span style=display:flex><span>  NonMaskableInt_IRQn    <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>14</span>,             <span style=color:#75715e>/*!&lt; -14 Cortex-M Non Maskable Interrupt      */</span>
</span></span><span style=display:flex><span>  HardFault_IRQn         <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>13</span>,             <span style=color:#75715e>/*!&lt; -13 Cortex-M Hard Fault Interrupt        */</span>
</span></span><span style=display:flex><span>  MemoryManagement_IRQn  <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>12</span>,             <span style=color:#75715e>/*!&lt; -12 Cortex-M Memory Management Interrupt */</span>
</span></span><span style=display:flex><span>  BusFault_IRQn          <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>11</span>,             <span style=color:#75715e>/*!&lt; -11 Cortex-M Bus Fault Interrupt         */</span>
</span></span><span style=display:flex><span>  UsageFault_IRQn        <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>,             <span style=color:#75715e>/*!&lt; -10 Cortex-M Usage Fault Interrupt       */</span>
</span></span><span style=display:flex><span>  SVCall_IRQn            <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>,              <span style=color:#75715e>/*!&lt; -5  Cortex-M SV Call Interrupt           */</span>
</span></span><span style=display:flex><span>  DebugMonitor_IRQn      <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>,              <span style=color:#75715e>/*!&lt; -4  Cortex-M Debug Monitor Interrupt     */</span>
</span></span><span style=display:flex><span>  PendSV_IRQn            <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>,              <span style=color:#75715e>/*!&lt; -2  Cortex-M Pend SV Interrupt           */</span>
</span></span><span style=display:flex><span>  SysTick_IRQn           <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,              <span style=color:#75715e>/*!&lt; -1  Cortex-M System Tick Interrupt       */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>/******  EFR32BG22 Peripheral Interrupt Numbers ******************************************/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  CRYPTOACC_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>,  <span style=color:#75715e>/*!&lt;  0 EFR32 CRYPTOACC Interrupt */</span>
</span></span><span style=display:flex><span>  TRNG_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,  <span style=color:#75715e>/*!&lt;  1 EFR32 TRNG Interrupt */</span>
</span></span><span style=display:flex><span>  PKE_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>,  <span style=color:#75715e>/*!&lt;  2 EFR32 PKE Interrupt */</span>
</span></span><span style=display:flex><span>  SMU_SECURE_IRQn        <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,  <span style=color:#75715e>/*!&lt;  3 EFR32 SMU_SECURE Interrupt */</span>
</span></span><span style=display:flex><span>  SMU_S_PRIVILEGED_IRQn  <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>,  <span style=color:#75715e>/*!&lt;  4 EFR32 SMU_S_PRIVILEGED Interrupt */</span>
</span></span><span style=display:flex><span>  SMU_NS_PRIVILEGED_IRQn <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,  <span style=color:#75715e>/*!&lt;  5 EFR32 SMU_NS_PRIVILEGED Interrupt */</span>
</span></span><span style=display:flex><span>  EMU_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>,  <span style=color:#75715e>/*!&lt;  6 EFR32 EMU Interrupt */</span>
</span></span><span style=display:flex><span>  TIMER0_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>,  <span style=color:#75715e>/*!&lt;  7 EFR32 TIMER0 Interrupt */</span>
</span></span><span style=display:flex><span>  TIMER1_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>,  <span style=color:#75715e>/*!&lt;  8 EFR32 TIMER1 Interrupt */</span>
</span></span><span style=display:flex><span>  TIMER2_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>,  <span style=color:#75715e>/*!&lt;  9 EFR32 TIMER2 Interrupt */</span>
</span></span><span style=display:flex><span>  TIMER3_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>, <span style=color:#75715e>/*!&lt; 10 EFR32 TIMER3 Interrupt */</span>
</span></span><span style=display:flex><span>  TIMER4_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>11</span>, <span style=color:#75715e>/*!&lt; 11 EFR32 TIMER4 Interrupt */</span>
</span></span><span style=display:flex><span>  RTCC_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>, <span style=color:#75715e>/*!&lt; 12 EFR32 RTCC Interrupt */</span>
</span></span><span style=display:flex><span>  USART0_RX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>13</span>, <span style=color:#75715e>/*!&lt; 13 EFR32 USART0_RX Interrupt */</span>
</span></span><span style=display:flex><span>  USART0_TX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>14</span>, <span style=color:#75715e>/*!&lt; 14 EFR32 USART0_TX Interrupt */</span>
</span></span><span style=display:flex><span>  USART1_RX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>, <span style=color:#75715e>/*!&lt; 15 EFR32 USART1_RX Interrupt */</span>
</span></span><span style=display:flex><span>  USART1_TX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>16</span>, <span style=color:#75715e>/*!&lt; 16 EFR32 USART1_TX Interrupt */</span>
</span></span><span style=display:flex><span>  ICACHE0_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>17</span>, <span style=color:#75715e>/*!&lt; 17 EFR32 ICACHE0 Interrupt */</span>
</span></span><span style=display:flex><span>  BURTC_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>, <span style=color:#75715e>/*!&lt; 18 EFR32 BURTC Interrupt */</span>
</span></span><span style=display:flex><span>  LETIMER0_IRQn          <span style=color:#f92672>=</span> <span style=color:#ae81ff>19</span>, <span style=color:#75715e>/*!&lt; 19 EFR32 LETIMER0 Interrupt */</span>
</span></span><span style=display:flex><span>  SYSCFG_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>20</span>, <span style=color:#75715e>/*!&lt; 20 EFR32 SYSCFG Interrupt */</span>
</span></span><span style=display:flex><span>  LDMA_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>21</span>, <span style=color:#75715e>/*!&lt; 21 EFR32 LDMA Interrupt */</span>
</span></span><span style=display:flex><span>  LFXO_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span>, <span style=color:#75715e>/*!&lt; 22 EFR32 LFXO Interrupt */</span>
</span></span><span style=display:flex><span>  LFRCO_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>23</span>, <span style=color:#75715e>/*!&lt; 23 EFR32 LFRCO Interrupt */</span>
</span></span><span style=display:flex><span>  ULFRCO_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span>, <span style=color:#75715e>/*!&lt; 24 EFR32 ULFRCO Interrupt */</span>
</span></span><span style=display:flex><span>  GPIO_ODD_IRQn          <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span>, <span style=color:#75715e>/*!&lt; 25 EFR32 GPIO_ODD Interrupt */</span>
</span></span><span style=display:flex><span>  GPIO_EVEN_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>26</span>, <span style=color:#75715e>/*!&lt; 26 EFR32 GPIO_EVEN Interrupt */</span>
</span></span><span style=display:flex><span>  I2C0_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>, <span style=color:#75715e>/*!&lt; 27 EFR32 I2C0 Interrupt */</span>
</span></span><span style=display:flex><span>  I2C1_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>28</span>, <span style=color:#75715e>/*!&lt; 28 EFR32 I2C1 Interrupt */</span>
</span></span><span style=display:flex><span>  EMUDG_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>29</span>, <span style=color:#75715e>/*!&lt; 29 EFR32 EMUDG Interrupt */</span>
</span></span><span style=display:flex><span>  EMUSE_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>, <span style=color:#75715e>/*!&lt; 30 EFR32 EMUSE Interrupt */</span>
</span></span><span style=display:flex><span>  AGC_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>31</span>, <span style=color:#75715e>/*!&lt; 31 EFR32 AGC Interrupt */</span>
</span></span><span style=display:flex><span>  BUFC_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>, <span style=color:#75715e>/*!&lt; 32 EFR32 BUFC Interrupt */</span>
</span></span><span style=display:flex><span>  FRC_PRI_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>33</span>, <span style=color:#75715e>/*!&lt; 33 EFR32 FRC_PRI Interrupt */</span>
</span></span><span style=display:flex><span>  FRC_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>34</span>, <span style=color:#75715e>/*!&lt; 34 EFR32 FRC Interrupt */</span>
</span></span><span style=display:flex><span>  MODEM_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>35</span>, <span style=color:#75715e>/*!&lt; 35 EFR32 MODEM Interrupt */</span>
</span></span><span style=display:flex><span>  PROTIMER_IRQn          <span style=color:#f92672>=</span> <span style=color:#ae81ff>36</span>, <span style=color:#75715e>/*!&lt; 36 EFR32 PROTIMER Interrupt */</span>
</span></span><span style=display:flex><span>  RAC_RSM_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>37</span>, <span style=color:#75715e>/*!&lt; 37 EFR32 RAC_RSM Interrupt */</span>
</span></span><span style=display:flex><span>  RAC_SEQ_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>38</span>, <span style=color:#75715e>/*!&lt; 38 EFR32 RAC_SEQ Interrupt */</span>
</span></span><span style=display:flex><span>  RDMAILBOX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>39</span>, <span style=color:#75715e>/*!&lt; 39 EFR32 RDMAILBOX Interrupt */</span>
</span></span><span style=display:flex><span>  RFSENSE_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>40</span>, <span style=color:#75715e>/*!&lt; 40 EFR32 RFSENSE Interrupt */</span>
</span></span><span style=display:flex><span>  PRORTC_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>41</span>, <span style=color:#75715e>/*!&lt; 41 EFR32 PRORTC Interrupt */</span>
</span></span><span style=display:flex><span>  SYNTH_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>, <span style=color:#75715e>/*!&lt; 42 EFR32 SYNTH Interrupt */</span>
</span></span><span style=display:flex><span>  WDOG0_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>43</span>, <span style=color:#75715e>/*!&lt; 43 EFR32 WDOG0 Interrupt */</span>
</span></span><span style=display:flex><span>  HFXO0_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>44</span>, <span style=color:#75715e>/*!&lt; 44 EFR32 HFXO0 Interrupt */</span>
</span></span><span style=display:flex><span>  HFRCO0_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>45</span>, <span style=color:#75715e>/*!&lt; 45 EFR32 HFRCO0 Interrupt */</span>
</span></span><span style=display:flex><span>  CMU_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>46</span>, <span style=color:#75715e>/*!&lt; 46 EFR32 CMU Interrupt */</span>
</span></span><span style=display:flex><span>  AES_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>47</span>, <span style=color:#75715e>/*!&lt; 47 EFR32 AES Interrupt */</span>
</span></span><span style=display:flex><span>  IADC_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>48</span>, <span style=color:#75715e>/*!&lt; 48 EFR32 IADC Interrupt */</span>
</span></span><span style=display:flex><span>  MSC_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>49</span>, <span style=color:#75715e>/*!&lt; 49 EFR32 MSC Interrupt */</span>
</span></span><span style=display:flex><span>  DPLL0_IRQn             <span style=color:#f92672>=</span> <span style=color:#ae81ff>50</span>, <span style=color:#75715e>/*!&lt; 50 EFR32 DPLL0 Interrupt */</span>
</span></span><span style=display:flex><span>  PDM_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>51</span>, <span style=color:#75715e>/*!&lt; 51 EFR32 PDM Interrupt */</span>
</span></span><span style=display:flex><span>  SW0_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>52</span>, <span style=color:#75715e>/*!&lt; 52 EFR32 SW0 Interrupt */</span>
</span></span><span style=display:flex><span>  SW1_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>53</span>, <span style=color:#75715e>/*!&lt; 53 EFR32 SW1 Interrupt */</span>
</span></span><span style=display:flex><span>  SW2_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>54</span>, <span style=color:#75715e>/*!&lt; 54 EFR32 SW2 Interrupt */</span>
</span></span><span style=display:flex><span>  SW3_IRQn               <span style=color:#f92672>=</span> <span style=color:#ae81ff>55</span>, <span style=color:#75715e>/*!&lt; 55 EFR32 SW3 Interrupt */</span>
</span></span><span style=display:flex><span>  KERNEL0_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>56</span>, <span style=color:#75715e>/*!&lt; 56 EFR32 KERNEL0 Interrupt */</span>
</span></span><span style=display:flex><span>  KERNEL1_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>57</span>, <span style=color:#75715e>/*!&lt; 57 EFR32 KERNEL1 Interrupt */</span>
</span></span><span style=display:flex><span>  M33CTI0_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>58</span>, <span style=color:#75715e>/*!&lt; 58 EFR32 M33CTI0 Interrupt */</span>
</span></span><span style=display:flex><span>  M33CTI1_IRQn           <span style=color:#f92672>=</span> <span style=color:#ae81ff>59</span>, <span style=color:#75715e>/*!&lt; 59 EFR32 M33CTI1 Interrupt */</span>
</span></span><span style=display:flex><span>  EMUEFP_IRQn            <span style=color:#f92672>=</span> <span style=color:#ae81ff>60</span>, <span style=color:#75715e>/*!&lt; 60 EFR32 EMUEFP Interrupt */</span>
</span></span><span style=display:flex><span>  DCDC_IRQn              <span style=color:#f92672>=</span> <span style=color:#ae81ff>61</span>, <span style=color:#75715e>/*!&lt; 61 EFR32 DCDC Interrupt */</span>
</span></span><span style=display:flex><span>  EUART0_RX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>62</span>, <span style=color:#75715e>/*!&lt; 62 EFR32 EUART0_RX Interrupt */</span>
</span></span><span style=display:flex><span>  EUART0_TX_IRQn         <span style=color:#f92672>=</span> <span style=color:#ae81ff>63</span>, <span style=color:#75715e>/*!&lt; 63 EFR32 EUART0_TX Interrupt */</span>
</span></span><span style=display:flex><span>} IRQn_Type;
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://microchipdeveloper.com/adc:adc-differential-nonlinearity>ADC Differential Non-linearity - Microchip Developer Helper</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuyangwang-git.github.io/tags/c/>C</a></li><li><a href=https://yuyangwang-git.github.io/tags/efr32/>EFR32</a></li></ul><nav class=paginav><a class=prev href=https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B05-pwm%E9%A9%B1%E5%8A%A8led%E7%81%AF/><span class=title>« Prev</span><br><span>EFR32 入门笔记 5: PWM 驱动 LED 灯</span></a>
<a class=next href=https://yuyangwang-git.github.io/posts/efr32%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B03-%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1/><span class=title>Next »</span><br><span>EFR32 入门笔记 3: 串口通信</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuyangwang-git.github.io>Yuyang Wang's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>