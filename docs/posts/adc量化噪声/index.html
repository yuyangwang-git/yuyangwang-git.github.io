<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ADC 量化噪声 | Yuyang Wang's Blog</title><meta name=keywords content="ADC"><meta name=description content="在一些 ADC 的应用笔记中常看到信噪比计算公式 SNR = 6.02N + 1.76dB，恰巧又在同学的课题里看到了该公式，于是深挖了一下这个公式的来龙去脉．"><meta name=author content><link rel=canonical href=https://yuyangwang-git.github.io/posts/adc%E9%87%8F%E5%8C%96%E5%99%AA%E5%A3%B0/><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.css integrity=sha384-bYdxxUwYipFNohQlHt0bjN/LCpueqWz13HufFEV1SUatKs1cm4L6fFgCi1jT643X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/katex.min.js integrity=sha384-Qsn9KnoKISj6dI8g7p1HBlNpVx0I8p1SvlwOldgi3IorMle61nQy4zEahWYtljaz crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})'></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PG166B7MZ2"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PG166B7MZ2",{anonymize_ip:!1})}</script><meta property="og:title" content="ADC 量化噪声"><meta property="og:description" content="在一些 ADC 的应用笔记中常看到信噪比计算公式 SNR = 6.02N + 1.76dB，恰巧又在同学的课题里看到了该公式，于是深挖了一下这个公式的来龙去脉．"><meta property="og:type" content="article"><meta property="og:url" content="https://yuyangwang-git.github.io/posts/adc%E9%87%8F%E5%8C%96%E5%99%AA%E5%A3%B0/"><meta property="og:image" content="https://yuyangwang-git.github.io/img/quantization.svg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-13T16:01:24+08:00"><meta property="article:modified_time" content="2022-10-13T16:01:24+08:00"><meta property="og:site_name" content="Yuyang Wang's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yuyangwang-git.github.io/img/quantization.svg"><meta name=twitter:title content="ADC 量化噪声"><meta name=twitter:description content="在一些 ADC 的应用笔记中常看到信噪比计算公式 SNR = 6.02N + 1.76dB，恰巧又在同学的课题里看到了该公式，于是深挖了一下这个公式的来龙去脉．"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://yuyangwang-git.github.io/posts/"},{"@type":"ListItem","position":3,"name":"ADC 量化噪声","item":"https://yuyangwang-git.github.io/posts/adc%E9%87%8F%E5%8C%96%E5%99%AA%E5%A3%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ADC 量化噪声","name":"ADC 量化噪声","description":"在一些 ADC 的应用笔记中常看到信噪比计算公式 SNR = 6.02N + 1.76dB，恰巧又在同学的课题里看到了该公式，于是深挖了一下这个公式的来龙去脉．","keywords":["ADC"],"articleBody":"采样与量化过程 模拟信号可视为时间相关的连续函数（如上图），该函数在任意时刻的值被称为信号的幅度．因此，在将连续的模拟信号转换为离散化的数字信号过程中，涉及到两个步骤：\n在连续的时间轴上对信号进行离散化，即采样（sampling） 在连续的幅度轴上对信号进行离散化，即量化（quantization） 将模拟信号转换为数字信号的过程必然伴随着信息的丢失（信号失真），为保证数字信号能尽可能准确的反应原始模拟信号的特征，就需要提高采样及量化的精度．\n采样的精度由采样率（sampling rate）决定，量化的精度则由量化位数（对应 ADC 的转换位数）决定．\n在实践中受限于成本等因素，我们不能无限制的提高信号的采样率和量化位数．所幸，当采样率满足一定条件时，我们可以从采样结果中无失真地恢复原始信号．\n对于频谱分布在 $(0, f_h)$ 之间的带限信号，当采样频率 $f_s$ 满足 $f_s\u003e2f_h$ 时，可以无失真的恢复原始信号．\n— Nyquist 低通采样定律\n与采样不同，量化过程一定会引入无法恢复的量化误差（上图给出了封面中量化结果的误差曲线，即 $y = signal - quantization$），本文将讨论量化误差的产生及其对信号质量的影响．\n为什么量化误差无法恢复？\n量化在输入与输出之间建立起一种从多到少的映射，多个不同的输入将对应同一个输出，该过程伴随大量原始信息丢失，无法仅靠输出值恢复出原有的输入值，因此量化是一个不可逆的过程．\n采样过程也伴随信息的丢失，但为什么信号仍然可以被无失真的恢复？\n在产生这一疑问之前，对 Nyquist 低通采样定律成立的前提条件没有一个更清晰的认识．\n如果我们已知函数上若干等间距点$(x_i, y_i)$，能从这些点求出函数的解析式吗？当然不能，因为我们可以构造出无穷多个满足$y_i=f(x_i)$的函数$f(x)$．\n如果增加前提条件，限制该函数为正弦函数呢？依然不能求出解析式，因为还是可以构造出无穷多个经过这些点正弦函数，只需保证这些正弦函数的周期成倍数关系即可．\n现在回过头来看采样定理，“频谱分布在 $(0, f_h)$ 之间的带限信号”，我们把信号分解为若干具有不同频率的正弦分量，其中最高频率分量的频率记为 $f_h$ ，是一个有限值．这是一个非常强的限制条件，强到现实中几乎找不到这样的理想带限信号．\n在这一前提下，信号的最高频率分量也只是一个频率小于等于 $f_h$ 的正弦波，所以只要采样频率大于 $2f_h$，自然可以计算出该信号的波形．\n能否突破采样定理的限制？\n在前面的论述中，刻意强调了等间距的表述，这是因为采样定理中已经指定采样频率为恒定值 $f_s$．那如果采取非均匀采样策略，能否以较低的采样频率恢复出更高频的信号呢？这就是 Terence Tao 等在 2007 年提出的压缩感知（compressed sensing）理论中回答的问题——当信号具有稀疏性时，能以远低于采样定理所要求的采样数重建原始信号．\n量化 正如前面所讨论的，量化是将在数轴上连续信号的幅值近似为位数有限的离散值的过程（如封面），该过程由量化器（quantizer）实现．\n实际上，我们所熟知的四舍五入算法就是一种最基本的量化器，该算法将带有小数部分的输入映射到了最接近的整数，构成了一种 Mid-Tread 型均匀量化器．\n量化可分为均匀量化和非均匀量化，本文仅讨论最常见的均匀量化．均匀量化的量化级为定值．\n量化级，采样位数，采样位深等词语都是同一个概念的不同表述方法．\n均匀量化器包含 “Mid-Tread” 和 “Mid-Rise” 两种类型，二者的图像可参考下图：\n这两种类型的命名与原点的位置有关，如果我们把量化形成的阶梯状信号比作楼梯，Mid-Tread 指原点落在楼梯踏步中间时的情形，而 Mid-Rise 指原点落在楼梯梯面时的情形．\nTread 和 Riser 指楼梯踏步（stair tread）和楼梯梯面（stair riser）\nTread: the part you step on.\nRiser: the vertical part behind the tread. Combined with the tread, this creates the step.\n— Defining the components of a commercial stairway system1\n绝大多数 ADC 都属于 Mid-Tread 型量化器．以德州仪器的 12 位 ADC TLC2543-EP 为例，厂商在数据手册中给出了器件的输入输出关系：\n该芯片为一个典型的 Mid-Tread 量化器，当该芯片的 $V_{ref+}$ 和 $V_{ref-}$ 两个引脚被恰当连接时，芯片的 LSB 为 1.2mV．\nn-bit ADC 的转换结果对应 $2^n$ 个数字量，每个数字量对应一个模拟电平，最低位数字量所对应的模拟电平被称为最小有效位（Least Significant Bit，LSB），n 也被称为 ADC 的分辨率．\n量化误差 本节将介绍一个量化误差的近似计算模型，尽管该模型是在一些假设的基础上提出的，但依然可以用于绝大多数信号的信噪比分析．\nTLC2543-EP 在特定工况下 LSB 为 1.2mV，即芯片无法捕获小于 1.2mV 的电压变化．这就意味着芯片的输出与真实值之间存在量化误差 $e_{q}$，此时对于任意的输入信号（当然，输入信号的大小不能超过 ADC 量程），芯片产生的量化误差的最大值 $e_{qmax}$ 满足：\n$$ e_q = Input - Output \\leqslant e_{qmax} = \\frac{1}{2} LSB $$\n显然，量化误差的大小与输入信号是直接相关的，但是如果我们考虑到两个事实：\n实际使用 ADC 采样时，会将 ADC 的动态范围与输入信号的最大幅度进行匹配以获得最大分辨率，此时输入信号将横跨若干 LSB； 相信没有傻子会干出浪费 ADC 分辨率的蠢事来，采样微弱交流信号时会使用前置放大器或调整 ADC 的参考电压．\n为了尽可能的提高分辨率，我们会倾向于选择具有更高位数的 ADC． 就可以对量化误差做进一步的简化，将其视为一个叠加在原始信号上的锯齿状噪声，且我们近似的认为该噪声与输入无关：\n实际上这种假设对于绝大多数信号都是成立的，对于图示的锯齿状噪声，我们可以计算其 RMS：\n$$ {RMS}_{noise} = \\sqrt{\\dfrac{{LSB}^2}{12}} = \\dfrac{LSB}{\\sqrt{12}} $$\n${RMS}^2$ 为均方值（对幅值的平方求平均值），反映了信号功率；\n$RMS$ 为均方根，也即有效值，二者均可用于信噪比的计算．\n上式可以看出，该模型下，量化噪声的功率只与 ADC 的最小分辨率有关，而与采样频率无关．\n接下来就可以计算 ADC 的理想信噪比：\n$$ SNR = 20\\lg\\dfrac{{RMS}_{signal}}{{RMS}_{noise}} $$\n为了给出 ADC 信噪比的计算公式，我们可以假设输入信号为正弦波，其峰-峰值恰覆盖 ADC 的量程，即：\n$$ V_{input} = \\dfrac{2^{n}}{2} LSB \\cdot \\sin(\\omega x) $$\n而正弦波的有效值为：\n$$ RMS_{signal}= \\dfrac{2^n}{2 \\sqrt{2}}LSB $$\n故理想信噪比为：\n$$ \\begin{aligned} SNR \u0026= 20\\lg\\dfrac{{RMS}_{signal}}{{RMS}_{noise}} \\\\ \u0026= 20\\lg 2^n + 20\\lg\\sqrt{\\dfrac{3}{2}} \\\\ \u0026\\approx 6.02N + 1.76dB \\end{aligned} $$\n如何最小化量化误差的影响 选择具有更高分辨率的 ADC，如 16bit 甚至 24bit 的型号． 过采样 + 数字滤波 待完善．\nHow To Design a Commercial Stairway. ↩︎\n","wordCount":"258","inLanguage":"en","image":"https://yuyangwang-git.github.io/img/quantization.svg","datePublished":"2022-10-13T16:01:24+08:00","dateModified":"2022-10-13T16:01:24+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://yuyangwang-git.github.io/posts/adc%E9%87%8F%E5%8C%96%E5%99%AA%E5%A3%B0/"},"publisher":{"@type":"Organization","name":"Yuyang Wang's Blog","logo":{"@type":"ImageObject","url":"https://yuyangwang-git.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yuyangwang-git.github.io accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yuyangwang-git.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yuyangwang-git.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://example.org title=Server><span>Server</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yuyangwang-git.github.io>Home</a>&nbsp;»&nbsp;<a href=https://yuyangwang-git.github.io/posts/>Posts</a></div><h1 class=post-title>ADC 量化噪声<sup><span class=entry-isdraft>&nbsp;&nbsp;[draft]</span></sup></h1><div class=post-meta><span title='2022-10-13 16:01:24 +0800 CST'>October 13, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;258 words</div></header><figure class=entry-cover><img loading=lazy src=https://yuyangwang-git.github.io/posts/adc%E9%87%8F%E5%8C%96%E5%99%AA%E5%A3%B0/img/quantization.svg alt></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#采样与量化过程>采样与量化过程</a></li><li><a href=#量化>量化</a><ul><li><a href=#量化误差>量化误差</a></li><li><a href=#如何最小化量化误差的影响>如何最小化量化误差的影响</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=采样与量化过程>采样与量化过程<a hidden class=anchor aria-hidden=true href=#采样与量化过程>#</a></h2><p><img loading=lazy src=img/analog.svg#center alt=analog></p><p>模拟信号可视为时间相关的连续函数（如上图），该函数在任意时刻的值被称为信号的幅度．因此，在将连续的模拟信号转换为离散化的数字信号过程中，涉及到两个步骤：</p><ol><li>在连续的时间轴上对信号进行离散化，即采样（sampling）</li><li>在连续的幅度轴上对信号进行离散化，即量化（quantization）</li></ol><p>将模拟信号转换为数字信号的过程必然伴随着信息的丢失（信号失真），为保证数字信号能尽可能准确的反应原始模拟信号的特征，就需要提高采样及量化的精度．</p><p>采样的精度由采样率（sampling rate）决定，量化的精度则由量化位数（对应 ADC 的转换位数）决定．</p><p>在实践中受限于成本等因素，我们不能无限制的提高信号的采样率和量化位数．所幸，当采样率满足一定条件时，我们可以从采样结果中无失真地恢复原始信号．</p><blockquote><p><strong>对于频谱分布在 $(0, f_h)$ 之间的带限信号</strong>，当采样频率 $f_s$ 满足 $f_s>2f_h$ 时，可以无失真的恢复原始信号．</p><p>— Nyquist 低通采样定律</p></blockquote><p><img loading=lazy src=img/error.svg#center alt="quantization error"></p><p>与采样不同，量化过程一定会引入无法恢复的量化误差（上图给出了封面中量化结果的误差曲线，即 $y = signal - quantization$），本文将讨论量化误差的产生及其对信号质量的影响．</p><blockquote><p><strong>为什么量化误差无法恢复？</strong></p><p>量化在输入与输出之间建立起一种从多到少的映射，多个不同的输入将对应同一个输出，该过程伴随大量原始信息丢失，无法仅靠输出值恢复出原有的输入值，因此量化是一个不可逆的过程．</p><p><strong>采样过程也伴随信息的丢失，但为什么信号仍然可以被无失真的恢复？</strong></p><p>在产生这一疑问之前，对 Nyquist 低通采样定律成立的前提条件没有一个更清晰的认识．</p><p>如果我们已知函数上<strong>若干等间距点$(x_i, y_i)$</strong>，能从这些点求出函数的解析式吗？当然不能，因为我们可以构造出无穷多个满足$y_i=f(x_i)$的函数$f(x)$．</p><p>如果增加前提条件，限制该函数为正弦函数呢？依然不能求出解析式，因为还是可以构造出无穷多个经过这些点正弦函数，只需保证这些正弦函数的周期成倍数关系即可．</p><p>现在回过头来看采样定理，<strong>“频谱分布在 $(0, f_h)$ 之间的带限信号”</strong>，我们把信号分解为若干具有不同频率的正弦分量，其中最高频率分量的频率记为 $f_h$ ，是一个有限值．这是一个非常强的限制条件，强到现实中几乎找不到这样的理想带限信号．</p><p>在这一前提下，信号的最高频率分量也只是一个频率小于等于 $f_h$ 的正弦波，所以只要采样频率大于 $2f_h$，自然可以计算出该信号的波形．</p><p><strong>能否突破采样定理的限制？</strong></p><p>在前面的论述中，刻意强调了<strong>等间距</strong>的表述，这是因为采样定理中已经指定采样频率为恒定值 $f_s$．那如果采取<strong>非均匀采样</strong>策略，能否以较低的采样频率恢复出更高频的信号呢？这就是 Terence Tao 等在 2007 年提出的<strong>压缩感知</strong>（compressed sensing）理论中回答的问题——当信号具有稀疏性时，能以远低于采样定理所要求的采样数重建原始信号．</p></blockquote><h2 id=量化>量化<a hidden class=anchor aria-hidden=true href=#量化>#</a></h2><p>正如前面所讨论的，量化是将在数轴上连续信号的幅值近似为位数有限的离散值的过程（如封面），该过程由量化器（quantizer）实现．</p><p>实际上，我们所熟知的四舍五入算法就是一种最基本的量化器，该算法将带有小数部分的输入映射到了最接近的整数，构成了一种 Mid-Tread 型均匀量化器．</p><blockquote><p>量化可分为均匀量化和非均匀量化，本文仅讨论最常见的均匀量化．均匀量化的量化级为定值．</p></blockquote><blockquote><p>量化级，采样位数，采样位深等词语都是同一个概念的不同表述方法．</p></blockquote><p>均匀量化器包含 “Mid-Tread” 和 “Mid-Rise” 两种类型，二者的图像可参考下图：</p><p><img loading=lazy src=img/quantization_types.jpg#center alt="quantization type" title="Mid-Rise 与 Mid-Tread 量化类型"></p><blockquote><p>这两种类型的命名与原点的位置有关，如果我们把量化形成的阶梯状信号比作楼梯，Mid-Tread 指原点落在楼梯踏步中间时的情形，而 Mid-Rise 指原点落在楼梯梯面时的情形．</p><p>Tread 和 Riser 指楼梯踏步（stair tread）和楼梯梯面（stair riser）</p><p><img loading=lazy src=img/stairway.png#center alt="stairway system components"></p><p>Tread: the part you step on.</p><p>Riser: the vertical part behind the tread. Combined with the tread, this creates the step.</p><p>— Defining the components of a commercial stairway system<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><p>绝大多数 ADC 都属于 Mid-Tread 型量化器．以德州仪器的 12 位 ADC TLC2543-EP 为例，厂商在数据手册中给出了器件的输入输出关系：</p><p><img loading=lazy src=img/transfer_characteristic.svg#center alt=transfer_characteristic></p><p>该芯片为一个典型的 Mid-Tread 量化器，当该芯片的 $V_{ref+}$ 和 $V_{ref-}$ 两个引脚被恰当连接时，芯片的 LSB 为 1.2mV．</p><blockquote><p>n-bit ADC 的转换结果对应 $2^n$ 个数字量，每个数字量对应一个模拟电平，最低位数字量所对应的模拟电平被称为最小有效位（Least Significant Bit，LSB），n 也被称为 ADC 的分辨率．</p></blockquote><h3 id=量化误差>量化误差<a hidden class=anchor aria-hidden=true href=#量化误差>#</a></h3><blockquote><p>本节将介绍一个量化误差的近似计算模型，尽管该模型是在一些假设的基础上提出的，但依然可以用于绝大多数信号的信噪比分析．</p></blockquote><p>TLC2543-EP 在特定工况下 LSB 为 1.2mV，即芯片无法捕获小于 1.2mV 的电压变化．这就意味着芯片的输出与真实值之间存在量化误差 $e_{q}$，此时对于任意的输入信号（当然，输入信号的大小不能超过 ADC 量程），芯片产生的量化误差的最大值 $e_{qmax}$ 满足：</p><p>$$
e_q = Input - Output \leqslant e_{qmax} = \frac{1}{2} LSB
$$</p><p>显然，量化误差的大小与输入信号是直接相关的，但是如果我们考虑到两个事实：</p><ol><li>实际使用 ADC 采样时，会将 ADC 的动态范围与输入信号的最大幅度进行匹配以获得最大分辨率，<strong>此时输入信号将横跨若干 LSB</strong>；</li></ol><blockquote><p><del>相信没有傻子会干出浪费 ADC 分辨率的蠢事来</del>，采样微弱交流信号时会使用前置放大器或调整 ADC 的参考电压．</p></blockquote><ol start=2><li>为了尽可能的提高分辨率，我们会倾向于选择具有更高位数的 ADC．</li></ol><p>就可以对量化误差做进一步的简化，将其视为一个叠加在原始信号上的锯齿状噪声，且我们近似的认为该噪声与输入无关：</p><p><img loading=lazy src=img/ideal_quantization_error.svg#center alt=s></p><p>实际上这种假设对于绝大多数信号都是成立的，对于图示的锯齿状噪声，我们可以计算其 RMS：</p><p>$$
{RMS}_{noise} = \sqrt{\dfrac{{LSB}^2}{12}} = \dfrac{LSB}{\sqrt{12}}
$$</p><blockquote><ul><li><p>${RMS}^2$ 为均方值（对幅值的平方求平均值），反映了信号功率；</p></li><li><p>$RMS$ 为均方根，也即有效值，二者均可用于信噪比的计算．</p></li></ul></blockquote><p>上式可以看出，该模型下，量化噪声的功率只与 ADC 的最小分辨率有关，而与采样频率无关．</p><p>接下来就可以计算 ADC 的理想信噪比：</p><p>$$
SNR = 20\lg\dfrac{{RMS}_{signal}}{{RMS}_{noise}}
$$</p><p>为了给出 ADC 信噪比的计算公式，我们可以假设输入信号为正弦波，其峰-峰值恰覆盖 ADC 的量程，即：</p><p>$$
V_{input} = \dfrac{2^{n}}{2} LSB \cdot \sin(\omega x)
$$</p><p>而正弦波的有效值为：</p><p>$$
RMS_{signal}= \dfrac{2^n}{2 \sqrt{2}}LSB
$$</p><p>故理想信噪比为：</p><p>$$
\begin{aligned}
SNR &= 20\lg\dfrac{{RMS}_{signal}}{{RMS}_{noise}} \\
&= 20\lg 2^n + 20\lg\sqrt{\dfrac{3}{2}} \\
&\approx 6.02N + 1.76dB
\end{aligned}
$$</p><h3 id=如何最小化量化误差的影响>如何最小化量化误差的影响<a hidden class=anchor aria-hidden=true href=#如何最小化量化误差的影响>#</a></h3><ol><li>选择具有更高分辨率的 ADC，如 16bit 甚至 24bit 的型号．</li><li>过采样 + 数字滤波</li></ol><p>待完善．</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://blog.manningtoncommercial.com/how-to-design-a-commercial-stairway>How To Design a Commercial Stairway</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://yuyangwang-git.github.io/tags/adc/>ADC</a></li></ul><nav class=paginav><a class=prev href=https://yuyangwang-git.github.io/posts/%E5%85%83%E4%BB%B6%E5%8F%82%E6%95%B0%E8%AF%AF%E5%B7%AE%E5%AF%B9cmrr%E7%9A%84%E5%BD%B1%E5%93%8D/><span class=title>« Prev</span><br><span>元件参数误差对 CMRR 的影响</span></a>
<a class=next href=https://yuyangwang-git.github.io/posts/stm32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/><span class=title>Next »</span><br><span>STM32 启动流程</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://yuyangwang-git.github.io>Yuyang Wang's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>